# -*- coding: utf-8 -*-
## import django 
from django.shortcuts import get_object_or_404, render, redirect
from django.http import HttpResponse
from django.template import loader
from django.conf import settings
from django.core.files.storage import FileSystemStorage
from django.contrib.auth.models import User

## import methods defined on utils.py
from .utils.sample_convertion import *
from .utils.stats_calculation import *


from .models import *


import re, os, shutil
import datetime, time

# import pdb; pdb.set_trace()


def index(request):
    #latest_question_list = Question.objects.order_by('-pub_date')[:5]
    #context = {'latest_question_list': latest_question_list}
    return render(request, 'wetlab/index.html')

def get_sample_file (request):
    if request.method == 'POST' and (request.POST['action']=='uploadFile'):
        ### First step in collecting data from the NextSeq run. Sample Sheet and experiment name are required
        
        get_user_names={}
        projects=[]
        run_name=request.POST['runname']
        myfile = request.FILES['myfile']
        ## check that runName is not already used in the database. Error page is showed if runName is already  defined
        if (RunProcess.objects.filter(runName = run_name)).exists():
            return render (request,'wetlab/error_page.html', {'content':['Run Name is already used. ','Run Name must be unique in database.',' ',
                                                            'ADVICE:','Change the value of run name in the "run name Field"']})
        ## check if file contains the extension. Error page is showed if file does not contain any extension
        try:
            split_filename=re.search('(.*)(\.\w+$)',myfile.name)
        except:
            return render (request,'wetlab/error_page.html', {'content':['Uploaded file does not containt extension', 'Sample Sheet must have a csv extension','',
                                                            'ADVICE:','Select the Sample file generated by Illumina Experient Manager (IEM)']})
        ext_file=split_filename.group(2)
        ## check if file contains the csv extension. Error page is showed if file does not contain the csv extension
        if ext_file != '.csv':
            return render (request,'wetlab/error_page.html', {'content':['Sample Sheet must have a csv extension','',
                                                            'ADVICE:','Select the Sample file generated by Illumina Experient Manager (IEM)']})
        fs = FileSystemStorage()
        timestr = time.strftime("%Y%m%d-%H%M%S")
        ## including the timestamp to the sample sheet file
        file_name=str('documents/' + split_filename.group(1) + timestr + ext_file)
        filename = fs.save(file_name,  myfile)
        uploaded_file_url = fs.url(filename)
        
        ### add the document directory to read the csv file
        stored_file=str('wetlab/documents/' + file_name)
        ## Fetch from the Sample Sheet file the projects included in the run and the user. Error page is showed if not project/description colunms are found
        try:        
            project_list=get_projects_in_run(stored_file)
        except:
            ## delete sample sheet file 
            fs.delete(file_name)
            return render (request,'wetlab/error_page.html', {'content':['Sample Sheet does not contain "Sample_proyect" and/or "Description" fields','',
                                                            'ADVICE:','Check that csv file generated by Illumina Experient Manager (IEM) includes these columns']})
        ## Check if the users are already defined on database. Error page is showed if users are not defined on database
        user_already_defined=[]
        for key, val  in project_list.items():
            if ( not User.objects.filter(username__icontains = val).exists()):
                user_already_defined.append(val)
        if (len(user_already_defined)>0):
            if (len(user_already_defined)>1):
                head_text='The following users are not defined in database:'
            else:
                head_text='The following user is not defined in database:'
            ## convert the list into string to display the user names on error page
            display_user= ' ,  '.join(user_already_defined)
            ## delete sample sheet file before showing the error page
            #import pdb; pdb.set_trace()
            fs.delete(file_name)
                
            return render (request,'wetlab/error_page.html', {'content':[ head_text,'', display_user,'', 
                           'Researcher names must be installed in database before uploading the Sample sheet']})
        ## Check if the projects are already defined on database. Error page is showed if projects are already defined on database
        #import pdb; pdb.set_trace()
        project_already_defined=[]
        for key, val  in project_list.items():
            if ( Projects.objects.filter(projectName__icontains = key).exists()):
                project_already_defined.append(val)
        if (len(project_already_defined)>0):
            if (len(project_already_defined)>1):
                head_text='The following projects are not defined in database:'
            else:
                head_text='The following project is not defined in database:'
            ## convert the list into string to display the user names on error page
            display_project= ''.join(project_already_defined)
                ## delete sample sheet file before showing the error page
            fs.delete(file_name)
            return render (request,'wetlab/error_page.html', {'content':[ head_text,'', display_project,'', 
                          'Project names must be unique','', 'ADVICE:','Edit the installed in the database before uploading the Sample sheet']})
        ##Once the information looks good. it will be stores in runProcess and projects table 
        

        #import pdb; pdb.set_trace()

        ## store data in runProcess table, run is in pre-recorded state
        run_proc_data = RunProcess(runName=run_name,sampleSheet= file_name, runState='Pre-Recorded')
        run_proc_data.save()
        
        ## create new project tables based on the project involved in the run and 
        ## include the project information in projects variable to build the new FORM
        #import pdb; pdb.set_trace()
        for key, val  in project_list.items():
            userid=User.objects.get(username__exact = val)
            p_data=Projects(runprocess_id=RunProcess.objects.get(runName =run_name), projectName=key, user_id=userid)
            p_data.save()
            projects.append([key, val])
        projects.append(['runname', request.POST['runname']])
        ## displays the list of projects and the user names found on Sample Sheet
        return render(request, 'wetlab/getSampleSheet.html', {'get_user_names': projects })
        
    elif request.method=='POST' and (request.POST['action']=='displayResult'):
        projects=request.POST.getlist('project')
        user_name=request.POST.getlist('username')
        library_kit=request.POST.getlist('librarykit')
        run_name= request.POST['runname']
        ## get the sample sheet used in the run
        
        run_p = RunProcess.objects.get(runName__exact = run_name)
        s_file=run_p.get_sample_file()
        ## get the different type of library kit used in the run and 
        ## convert the sample sheet into Base Space. Number of converted 
        ## file will be the same as the number of different lybraries use in the run
        library={}
        bs_file={}
        results=[]
        
        in_file=str('wetlab/documents/' + s_file)
        #import pdb; pdb.set_trace()
        ## build the project list for each library kit 
        for x in range(len(library_kit)):
            if library_kit[x] in library :
                library[library_kit[x]].append(projects[x])
            else:
                library[library_kit[x]]= [projects[x]]
        ## convert the sample sheet to base space format and have different files according the library kit
        #import pdb; pdb.set_trace()
        for key, value in library.items():
            bs_file[key]=sample_sheet_map_basespace(in_file, key, value)
            results.append([key, bs_file[key]]) 
            
        ## save the project information on database
         
        for p in range(len( projects)):
            my_project = projects [p]
            my_name = user_name[p]
            my_libkit = library_kit[p]
            update_info_proj=Projects.objects.get(projectName = my_project)
            update_info_proj.libraryKit=my_libkit
            update_info_proj.baseSpaceFile=bs_file[my_libkit]
            update_info_proj.proState='Recorded'
            update_info_proj.save()
        #import pdb; pdb.set_trace()
        results.append(['runname', run_name])
        
        #import pdb; pdb.set_trace()
        ## save the sample sheet file under tmp/recorded to be processed when run folder was created
        subfolder_name=str(run_p.id)
        import pdb; pdb.set_trace()
        os.mkdir(os.path.join('wetlab/tmp/recorded', subfolder_name ))
        sample_sheet_copy= os.path.join('wetlab/tmp/recorded', subfolder_name, 'samplesheet.csv' )
        shutil.copy(in_file,sample_sheet_copy)
        ## update the state of the run to 'Recorded'
        run_p.runState='Recorded'
        run_p.save()
        
        return render (request, 'wetlab/getSampleSheet.html', {'completed_form':results})
    

    return render(request, 'wetlab/getSampleSheet.html')

def get_information_run(run_name_found,run_id):
    info_dict={}
    ## collect the state to get the valid information of run that matches the run name 
    run_state=run_name_found[0].get_state()
    if (run_state != 'Completed'):
        d_list=['Run name','State of the Run is','Run was requested by','The Sample Sheet used is','Run was recorded on date']
    else:
        d_list=['Run name','State of the Run is','Run was requested by','Disk space used for Images','Disk space used for Fasta Files','Disk space used for other Files','Run recorded date'] 
    run_info_data=run_name_found[0].get_info_process().split(';')
    r_data_display=[] 
    for i in range (len (d_list)):
        r_data_display.append([d_list[i],run_info_data[i]])
    info_dict['data']=r_data_display
    if (run_state == 'Recorded'):
        info_dict['graphic']='25-percentage.gif'
    if (run_state == 'Sample Sent'):
        info_dict['graphic']='40-percentage.gif'
    if (run_state == 'Process Running'):
        info_dict['graphic']='50-percentage.gif'
    if (run_state == 'Bcl2Fastq Executed'):
        info_dict['graphic']='60-percentage.gif'
        # finding the running parameters index for the run
        runName_id=RunningParameters.objects.get(pk=run_id)
        # Adding the Run Parameters information
        rp_list=['Run ID','Experiment Name ','RTA version ','System Suite Version','Library ID ','Chemistry','Run Start Date', 'Analysis Work Flow Type','Run Management Type','Planned Read1 Cycles',
                'Planned Read2 Cycles','Planned Index1 Read Cycles','Planned Index2 Read Cycles','Application Version','Num Tiles per Swatch','Image Channel',
                'Flowcel','Image Dimensions', 'Flowcell Layout']
        rp_data=runName_id.get_run_parameters_info().split(';')
        r_rp_display=[]
        for i in range (len(rp_list)):
            if i == 'Image Channel':
                img_data_list=rp_data[i].split(',')
                r_rp_display.append([rp_list[i],[img_data_list]])
            else:
                r_rp_display.append([rp_list[i], rp_data[i]])
        info_dict['parameters']=r_rp_display
        ### BaseSpaceFile.objects.get(pk=Document.objects.get(run_name=run_name_value).id)
    
    p_list= Projects.objects.filter(runprocess_id=run_id)
    if p_list !='':
        #import pdb; pdb.set_trace()
        p_data_list=[]
        for p in range (len(p_list)):
            p_data_list.append([p_list[p].projectName,p_list[p].id])
        info_dict['projects']=p_data_list
    #import pdb; pdb.set_trace()
    return info_dict
    
   

def search_nextSeq (request):
    if request.method=='POST' and (request.POST['action']=='runsearch'):
        ## Define the variable run_fuzzy to '', in case check box is not checked
        if 'runfuzzysearch' in request.POST:
            run_fuzzy=request.POST['runfuzzysearch']
        else:
            run_fuzzy=''
            ## Define the variable search_all to '', in case check box is not checked
        if 'searchall' in request.POST:
            search_all=request.POST['searchall']
        else:
            search_all=''
        run_name=request.POST['runname']
        start_date=request.POST['startdate']
        end_date=request.POST['enddate']
        run_state=request.POST['runstate']
        
        #############################################################
        ## Search for a single match 
        #############################################################
        if (run_name !='' and run_fuzzy ==''):
            if (RunProcess.objects.filter(runName__exact =run_name).exists()):
                run_name_found=RunProcess.objects.filter(runName__exact =run_name)
                if (len(run_name_found)>1):
                    return render (request,'wetlab/error_page.html', {'content':['Too many matches found when searching for the run name ', run_name ,
                                                                    'ADVICE:', 'Select the Fuzzy to gt the list for all matches runs ']})
                r_data_display= get_information_run(run_name_found,run_name_found[0].id)
                #import pdb; pdb.set_trace()
                return render(request, 'wetlab/SearchNextSeq.html', {'display_one_run': r_data_display })
            else:
                return render (request,'wetlab/error_page.html', {'content':['No matches have been found for the run name ', run_name ,
                                                                    'ADVICE:', 'Select the Fuzzy search button to get the match']})
        ############################################################# 
        ## check for the right format of the date fields  
        #############################################################
        if start_date !='' :
            try: 
                datetime.datetime.strptime(start_date, '%Y-%m-%d')
            except:
                return render (request,'wetlab/error_page.html', {'content':['The format for the "From Start Date" Field is incorrect ', 
                                                                    'ADVICE:', 'Use the format  (YYYY-MM-DD)']})
        if end_date !='' :
            try: 
                datetime.datetime.strptime(end_date, '%Y-%m-%d')
            except:
                return render (request,'wetlab/error_page.html', {'content':['The format for the "End Date Search" Field is incorrect ', 
                                                                    'ADVICE:', 'Use the format  (YYYY-MM-DD)']})
        if search_all :
            #############################################################
            #### searching for projects were match the run name and the state
            #############################################################
            if (run_name and run_fuzzy and run_state and start_date == '' and end_date == ''):
                if (RunProcess.objects.filter(runName__icontains =run_name, runState=run_state).exists()):
                    run_name_list=RunProcess.objects.filter(runName__icontains =run_name,runState=run_state)
                    if len(run_name_list)>1:
                        run_list=[]
                        for i in range(len(run_name_list)):
                            run_list.append([run_name_list[i],run_name_list[i].id])
                        #import pdb; pdb.set_trace()    
                        return render(request, 'wetlab/SearchNextSeq.html', {'display_run_list': run_list })
                    else:
                        r_data_display= get_information_run(run_name_list,run_name_list[0].id)
                        return render(request, 'wetlab/SearchNextSeq.html', {'display_one_run': r_data_display })
    
                else:
                    return render (request,'wetlab/error_page.html', {'content':['No matches have been found for the run name ', run_name ]})
            #############################################################
            #### searching for projects were match the run name , the state and start date
            #############################################################
            if (run_name and run_fuzzy and run_state and start_date != '' and end_date == ''):
            ## Date query search for date greater than run_date and less than start_date +1
            ## converting run_date to date for adding one day
                s_date= datetime.datetime.strptime(start_date, "%Y-%m-%d").date()
                end_date= str( s_date + datetime.timedelta(days=1))
                if (RunProcess.objects.filter(runName__icontains =run_name, runState=run_state, generatedat__range=(start_date, end_date)).exists()):
                    run_name_list=RunProcess.objects.filter(runName__icontains =run_name,runState=run_state, generatedat__range=(start_date, end_date))
                    if len(run_name_list)>1:
                        run_list=[]
                        for i in range(len(run_name_list)):
                            run_list.append([run_name_list[i],run_name_list[i].id])
                        #import pdb; pdb.set_trace()    
                        return render(request, 'wetlab/SearchNextSeq.html', {'display_run_list': run_list })
                    else:
                        r_data_display= get_information_run(run_name_list ,run_name_list[0].id)
                        return render(request, 'wetlab/SearchNextSeq.html', {'display_one_run': r_data_display })
                else:
                    return render (request,'wetlab/error_page.html', {'content':['No matches have been found for the run name ', run_name ]})
            #############################################################
            #### searching for projects were match the run name , the state and start and end date
            #############################################################
            if (run_name and run_fuzzy and run_state and start_date != '' and end_date != ''):
                if (RunProcess.objects.filter(runName__icontains =run_name, runState=run_state,generatedat__range=(start_date, end_date)).exists()):
                    run_name_list=RunProcess.objects.filter(runName__icontains =run_name,runState=run_state, generatedat__range=(start_date, end_date))
                    if len(run_name_list)>1:
                        run_list=[]
                        for i in range(len(run_name_list)):
                            run_list.append([run_name_list[i],run_name_list[i].id])
                        #import pdb; pdb.set_trace()    
                        return render(request, 'wetlab/SearchNextSeq.html', {'display_run_list': run_list })
                    else:
                        r_data_display= get_information_run(run_name_list,run_name_list[0].id)
                        return render(request, 'wetlab/SearchNextSeq.html', {'display_one_run': r_data_display })
                else:
                    return render (request,'wetlab/error_page.html', {'content':['No matches have been found for the run name ', run_name ]})
                    
            #############################################################
            #### searching for projects were match the state and start and end date
            #############################################################
            if (run_state and start_date != '' and end_date != ''):
                if (RunProcess.objects.filter(runName__icontains =run_name, runState=run_state, generatedat__range=(start_date, end_date)).exists()):
                    run_name_list=RunProcess.objects.filter(runState=run_state, generatedat__range=(start_date, end_date))
                    if len(run_name_list)>1:
                        run_list=[]
                        for i in range(len(run_name_list)):
                            run_list.append([run_name_list[i],run_name_list[i].id])
                        #import pdb; pdb.set_trace()    
                        return render(request, 'wetlab/SearchNextSeq.html', {'display_run_list': run_list })
                    else:
                        r_data_display= get_information_run(run_name_list,run_name_list[0].id)
                        return render(request, 'wetlab/SearchNextSeq.html', {'display_one_run': r_data_display })
                else:
                    return render (request,'wetlab/error_page.html', {'content':['No matches have been found for the run name ', run_name ]})       
            
            #############################################################
            #### searching for projects were match the state and start date
            #############################################################
            if (run_state and start_date != '' and end_date == ''):
                ## Date query search for date greater than run_date and less than start_date +1
                ## converting run_date to date for adding one day
                s_date= datetime.datetime.strptime(start_date, "%Y-%m-%d").date()
                end_date= str( s_date + datetime.timedelta(days=1))
                if (RunProcess.objects.filter(runName__icontains =run_name, runState=run_state,generatedat__range=(start_date, end_date)).exists()):
                    run_name_list=RunProcess.objects.filter(runState=run_state, generatedat__range=(start_date, end_date))
                    if len(run_name_list)>1:
                        run_list=[]
                        for i in range(len(run_name_list)):
                            run_list.append([run_name_list[i],run_name_list[i].id])
                        #import pdb; pdb.set_trace()    
                        return render(request, 'wetlab/SearchNextSeq.html', {'display_run_list': run_list })
                    else:
                        r_data_display= get_information_run(run_name_list,run_name_list[0].id)
                        return render(request, 'wetlab/SearchNextSeq.html', {'display_one_run': r_data_display })
                else:
                    return render (request,'wetlab/error_page.html', {'content':['No matches have been found for the run name ', run_name ]})       
                    
                    
        else:
            if (run_name !='' and run_fuzzy !=''):
                if (RunProcess.objects.filter(runName__icontains =run_name).exists()):
                    run_name_list=RunProcess.objects.filter(runName__icontains =run_name)
                    ## collect the list of run that matches the run name 
                    if len(run_name_list)>1:
                        run_list=[]
                        for i in range(len(run_name_list)):
                            run_list.append([run_name_list[i],run_name_list[i].id])
                        #import pdb; pdb.set_trace()    
                        return render(request, 'wetlab/SearchNextSeq.html', {'display_run_list': run_list })
                    else:
                        r_data_display= get_information_run(run_name_list,run_name_list[0].id)
                        return render(request, 'wetlab/SearchNextSeq.html', {'display_one_run': r_data_display })
                else:
                    return render (request,'wetlab/error_page.html', {'content':['No matches have been found for the run name ', run_name ]})
            
            ############################################################# 
            ##  searching for projects in the same state
            ############################################################# 
            if run_state:
                if (RunProcess.objects.filter(runState =run_state).exists()):
                    run_name_list=RunProcess.objects.filter(runState =run_state)
                        ## collect the list of run that matches the run name 
                    if len(run_name_list) >1:
                        run_list=[]
                        for i in range(len(run_name_list)):
                            run_list.append([run_name_list[i],run_name_list[i].id])
                            #import pdb; pdb.set_trace()    
                        return render(request, 'wetlab/SearchNextSeq.html', {'display_run_list': run_list })
                    else:
                        r_data_display= get_information_run(run_name_list,run_name_list[0].id)
                        return render(request, 'wetlab/SearchNextSeq.html', {'display_one_run': r_data_display })
                else:
                    return render (request,'wetlab/error_page.html', {'content':['No matches have been found for the run state ', run_state ]})
                      
            #############################################################
            #### searching for projects that were created after start date
            #############################################################
            if start_date:
                #import pdb; pdb.set_trace()
                if end_date =='':    
                    ## Date query search for date greater than run_date and less than start_date +1
                    ## converting run_date to date for adding one day
                    s_date= datetime.datetime.strptime(start_date, "%Y-%m-%d").date()
                    end_date= str( s_date + datetime.timedelta(days=1))
                if (RunProcess.objects.filter(generatedat__range=(start_date, end_date)).exists()):
                    run_name_list=RunProcess.objects.filter(generatedat__range=(start_date, end_date))
                    if (len(run_name_list)>1) :
                         ## collect the list of run that matches the run date 
                        run_list=[]
                        for i in range(len(run_name_list)):
                            run_list.append([run_name_list[i],run_name_list[i].id])
                            #import pdb; pdb.set_trace()    
                        return render(request, 'wetlab/SearchNextSeq.html', {'display_run_list': run_list })
                    else:
                        #import pdb; pdb.set_trace()
                        r_data_display  = get_information_run(run_name_list ,run_name_list[0].id)
                        return render(request, 'wetlab/SearchNextSeq.html', {'display_one_run': r_data_display })
                else:
                    return render (request,'wetlab/error_page.html', {'content':['No matches have been found for the run date ', start_date ]})

            #############################################################
            #### searching for projects that were created before end date
            #############################################################
            if end_date:
                    ## Date query search for date less than end_date                     ## converting run_date to date for adding one day 
                #import pdb; pdb.set_trace()
                if (RunProcess.objects.filter(generatedat__lte = end_date).exists()):
                    run_name_list=RunProcess.objects.filter(generatedat__range=(start_date, end_date))
                    if (len(run_name_list)>1) :
                         ## collect the list of run that matches the run date 
                        run_list=[]
                        for i in range(len(run_name_list)):
                            run_list.append([run_name_list[i],run_name_list[i].id])
                            #import pdb; pdb.set_trace()    
                        return render(request, 'wetlab/SearchNextSeq.html', {'display_run_list': run_list })
                    else:
                        r_data_display  = get_information_run(run_name_list ,run_name_list[0].id)
                        return render(request, 'wetlab/SearchNextSeq.html', {'display_one_run': r_data_display })
                else:
                    return render (request,'wetlab/error_page.html', {'content':['No matches have been found for the run date ', start_date ]})

                    ############################################################# 
                            

    
    #import pdb; pdb.set_trace()
    return render(request, 'wetlab/SearchNextSeq.html')


def search_run (request, run_id):
    #import pdb; pdb.set_trace()
    if (RunProcess.objects.filter(pk=run_id).exists()):
        run_name_found = RunProcess.objects.filter(pk=run_id)
        r_data_display  = get_information_run(run_name_found,run_id)
        return render(request, 'wetlab/SearchNextSeq.html', {'display_one_run': r_data_display })
    else:
        return render (request,'wetlab/error_page.html', {'content':['No matches have been found for the run  ', 
                                                                             'ADVICE:', 'Select the Fuzzy search button to get the match']})

def search_project (request, project_id):
    #import pdb; pdb.set_trace()
    if (Projects.objects.filter(pk=project_id).exists()):
        project_found = Projects.objects.filter(pk=project_id)
        p_data_display  = get_information_project(project_found)
        return render(request, 'wetlab/SearchNextSeq.html', {'display_one_run': r_data_display })
    else:
        return render (request,'wetlab/error_page.html', {'content':['No matches have been found for the run  ', 
                                                                             'ADVICE:', 'Select the Fuzzy search button to get the match']})





def downloadFile(request):
    #from urllib.parse import urlparse
    #from os.path import splitext, basename
    #filename = object_name.file.name.split('/')[-1]
    #path_to_file = '/home/bioinfo/web_carlosIII/wetlab/documents/test.pdf'
    #f = open(path_to_file, 'r',encoding='utf-8')
    #myfile = File(f)
    
    found=re.search('.*/wetlab/documents/(.*)\'>',str(request))
    if found:
        file_name=found.group(1)
    else:
        return render (request, 'wetlab/error_page.html', {'content':['File not found ', 'check with your administator']})
    #file_tmp_name=str(request).split('/')[-1]
    #temp_1=file_tmp_name.replace(">","")
    #file_name=temp_1.replace("'","")

    #disassembled = urlparse(str(request))
    #filename, file_ext = splitext(basename(disassembled.path))
    #file_name=str(filename + file_ext)
    #import pdb; pdb.set_trace()
    extension = file_name[-4:]
    if (extension == '.csv'):
        with open(os.path.join(settings.MEDIA_ROOT, file_name), 'r') as fh:
            response = HttpResponse(fh.read(),content_type="text/csv")
            response['Content-Disposition'] = 'attachment; filename=download.csv'
    #to open the file as text but pdf is binary. Change 'r' to 'rb' in open
    if (extension == 'xlsx'):
        #### For excel files use the  content_type='application/vnd.ms-excel'
        with open(os.path.join(settings.MEDIA_ROOT, file_name), 'rb') as fh:
            response = HttpResponse(fh.read(),content_type='application/vnd.ms-excel')
            response['Content-Disposition'] = 'attachment; filename=download.xlsx'
    if  (extension == '.pdf'):   
         # PDF file to be downloaded
        with open(os.path.join(settings.MEDIA_ROOT, file_name), 'rb') as fh:
        #with open(os.path.join(settings.MEDIA_ROOT, 'test.pdf'), 'rb') as fh:
            response = HttpResponse(fh.read(), content_type="application/pdf")
            response['Content-Disposition'] = 'attachment; filename=download.pdf'
    return response


#def result_form (request):
#    doc= Document.object.all()
#    return render(request , 'wetlab/result_form.html', {'form':doc})

#def results_run_folder (request):

#    return 
    #return render (request, 'results_run_folder.html', {'d_list':[info_data]})


'''    
def simple_upload(request):
    if request.method == 'POST' and request.FILES['myfile']:
        myfile = request.FILES['myfile']
        fs = FileSystemStorage()
        filename = fs.save(myfile.name,  myfile)
        uploaded_file_url = fs.url(filename)
        import pdb; pdb.set_trace()
        return render(request, 'wetlab/simple_upload.html', {
            'uploaded_file_url': uploaded_file_url
        })
    return render(request, 'wetlab/simple_upload.html')
'''

def model_form_upload(request):
    if request.method == 'POST':
        form = DocumentForm(request.POST, request.FILES)
        if form.is_valid():
            
            doc_tmp=str(form.cleaned_data.get('csv_file'))
            run_name_value=str(form.cleaned_data.get('run_name'))
            #import pdb; pdb.set_trace() 
            tmp_name = re.search('(.*\.csv$)',doc_tmp)
            if (tmp_name):
                form.save()
                name_in_file=tmp_name.group(1)
                if (re.search('\.csv$',name_in_file)):
                    #doc=str(name_in_file)
                    doc=str('wetlab/documents/documents/'+ name_in_file)
                    #import pdb; pdb.set_trace()
                    mapped_file=sample_sheet_map_basespace(doc).replace('wetlab/','')
                    #mapped_file=True ## checking the file can upload and download
                    if (mapped_file != 'Error'):
                        space_base = BaseSpaceFile( document=Document.objects.get(run_name=run_name_value), baseSpace_file = mapped_file)
                        space_base.save()
                        
                        #import pdb; pdb.set_trace()
                        ## ejemplo de conseguir el documento de base space con el nombre de la carrera
                        #dd = BaseSpaceFile.objects.get(document=Document.objects.get(run_name='juan run4'))
                        run_data=[]
                        tmp_data=[]
                        d_list=['Run folder name','Project name','User identity','Description of the run', 
                                'User name','Sample Sheet file', 'File was uploaded at date']
                        run_index= Document.objects.filter(run_name__icontains = run_name_value)
                        run_values=run_index[0].get_run_info().split(';')
                        #import pdb; pdb.set_trace()
                        for i in range (len (d_list)):
                            #tmp_data = d_list[i],run_values[i]
                            #run_data.append(tmp_data)
                            run_data.append([d_list[i],run_values[i]])
                            #tmp_data=[]
                        #import pdb; pdb.set_trace()
                        #tmp_data = 'BaseSpace file', mapped_file
                        run_data.append(['BaseSpace file', mapped_file]) 
                        return render (request , 'wetlab/resultsForm.html', {'r_data' : run_data} )

                    else:
                        #import pdb; pdb.set_trace()
                        Document.objects.get(run_name__icontains=run_name_value).delete() ## using django-clenup app to delete the uploaded file
                        return render (request,'wetlab/error_page.html', {'content':['Sample Sheet does not meet with the format']})
                else:
                    Document.objects.get(run_name__icontains=run_name_value).delete() ## using django-clenup app to delete the uploaded file
                    return render (request, 'wetlab/error_page.html',  {'content':['invalid extension of Sample Sheet file' , 'Extension must be csv']})
            else:
                return render (request, 'wetlab/error_page.html', {'content':['invalid extension of Sample Sheet file', 'Extension must be csv']})
    else:
        
        #form = DocumentForm()
        form = Docutres()
    return render(request, 'wetlab/modelForm_upload.html', {'form': form })

def get_run_data(request):
    if request.method =='POST':
        #form = DocumentForm(request.POST)
        run_data=[]
        tmp_data=[]
        d_list=['Run folder name','Project name','User identity','Description of the run', 
                'User name','Sample Sheet file', 'File was uploaded at date'] 
                #'File was uploaded at time:']
        form=request.POST
        r_name = str(form.get('run_name'))
        try:
            run_index= Document.objects.filter(run_name__icontains = r_name)
                          
        except:
            return render (request, 'wetlab/error_page.html', {'content':['The run  folder name   ', r_name, '  does not exist']})
        run_values=run_index[0].get_run_info().split(';')
        #import pdb; pdb.set_trace()
        for i in range (len (d_list)):
            if (d_list[i] == 'Run folder name'):
                run_name_value=run_values[i]
                
            #tmp_data = d_list[i],run_values[i]
            #run_data.append(tmp_data)
            #tmp_data=[]
            run_data.append([d_list[i],run_values[i]])
        #import pdb; pdb.set_trace()
        bs_file= BaseSpaceFile.objects.get(pk=Document.objects.get(run_name=run_name_value).id)
        #tmp_data = 'BaseSpace file', bs_file.baseSpace_file
        #run_data.append(tmp_data) 
        run_data.append(['BaseSpace file', bs_file.baseSpace_file])
        #import pdb; pdb.set_trace()
        return render (request , 'wetlab/results_run_folder.html', {'r_data' : run_data} )
    else:
        #form = DocumentForm()
        #return render (request, 'wetlab/get_run_data.html',{'form': form})
        return render (request, 'wetlab/get_run_data.html')


    

    
def test_stats (request):
    local_working_dir = '/home/bioinfo/web_carlosIII/wetlab/documents/uploadFromServer/'
    local_stats = '/home/bioinfo/web_carlosIII/wetlab/documents/uploadFromServer/Stats/'
    local_interop= '/home/bioinfo/web_carlosIII/wetlab/documents/uploadFromServer/Interop/'
    run_file = local_working_dir + 'RunInfo.xml'
    run_parameter=  local_working_dir + 'RunParameters.xml'
    running_data = get_running_data(run_file,run_parameter)
    ### get the run name to link the run with statistics data
    run_name_value= running_data['RunID']
    store_in_db(running_data, 'running_table',run_name_value)
    xml_statistics = get_statistics_xml(demux_file, conversion_file)
    store_in_db(xml_statistics, 'nextSeqXml_table',run_name_value)
    
    
  



    
    

