# -*- coding: utf-8 -*-
## import django
import statistics
import re, os, shutil, json
import datetime, time
from .fusioncharts.fusioncharts import FusionCharts

from django.shortcuts import get_object_or_404, render, redirect
from django.http import HttpResponse
from django.template import loader
from django.conf import settings
from django.core.files.storage import FileSystemStorage
from django.contrib.auth.models import User
from django.contrib.auth.decorators import login_required
#from django.contrib.auth.models import Group

from django_utils.models import Profile, Center
from django_utils.views import check_user_group
from .models import *

from iSkyLIMS_wetlab import wetlab_config
## import methods defined on utils.py
from .utils.sample_sheet_utils import *
from .utils.stats_calculation import *
from .utils.stats_graphics import *
from .utils.generic_functions import *
from .utils.library_kits import *
from .utils.fetching_information import *
from .utils.testing_wetlab_configuration import *
from .utils.sample_functions import *
from .utils.library_preparation import *
#from .utils.samplesheet_checks import *
#from .utils.parsing_run_info import get_machine_lanes
#from .utils.wetlab_misc_utilities import normalized_data
from iSkyLIMS_core.utils.handling_samples import *
from iSkyLIMS_core.utils.handling_protocols import *
from iSkyLIMS_core.utils.handling_comercial_kits import *

def index(request):
    #
    return render(request, 'iSkyLIMS_wetlab/index.html')

@login_required
def register_wetlab(request):
    #
    return render(request, 'iSkyLIMS_wetlab/index.html')


@login_required
def create_nextseq_run (request):
    ## Check user == WETLAB_MANAGER: if false,  redirect to 'login' page
    if request.user.is_authenticated:
        if not is_wetlab_manager(request):
            return render (
                request,'iSkyLIMS_wetlab/error_page.html',
                {'content':['You do not have enough privileges to see this page ',
                            'Contact with your administrator .']})
    else:
        #redirect to login webpage
        return redirect ('/accounts/login')


    ## FIRST STEP in collecting data from the NextSeq run. Sample Sheet and experiment name are required
    if request.method == 'POST' and (request.POST['action']=='uploadFile'):
        get_user_names={}
        projects=[]
        #run_name=request.POST['runname']
        myfile = request.FILES['myfile']

        ## CHECK if file contains the extension.
        ## Error page is showed if file does not contain any extension
        split_filename=re.search('(.*)(\.\w+$)',myfile.name)
        if None==split_filename:
            return render (
                request,'iSkyLIMS_wetlab/error_page.html',
                {'content':['Uploaded file does not containt extension',
                            'Sample Sheet must have a csv extension', '', 'ADVICE:',
                            'Select the Sample file generated by Illumina Experient Manager (IEM)']})
        ext_file=split_filename.group(2)

        ## CHECK if file contains the csv extension.
        ## Error page is shown if file does not contain the csv extension
        if ext_file != '.csv':
            return render (
                request,'iSkyLIMS_wetlab/error_page.html',
                {'content':['Sample Sheet must have a csv extension', '', 'ADVICE:',
                            'Select the Sample file generated by Illumina Experient Manager (IEM)']})
        fs = FileSystemStorage()
        timestr = time.strftime("%Y%m%d-%H%M%S")
        ## including the timestamp to the sample sheet file
        # do not need to include the absolute path because django uses
        # the MEDIA_ROOT variable defined on settings to upload the file
        file_name=str(wetlab_config.RUN_SAMPLE_SHEET_DIRECTORY
                     + split_filename.group(1)  + timestr + ext_file)
        filename = fs.save(file_name,  myfile)
        uploaded_file_url = fs.url(filename)

        ### add the document directory to read the csv file
        stored_file = os.path.join(settings.MEDIA_ROOT, file_name)

        ## Fetch the experiment name and the library name from the sample sheet file
        index_library_name = get_library_name(stored_file)
        run_name = get_experiment_name(stored_file)

        if run_name == '':
            ## define an temporary unique value for the run name
            #until the real value is get from user FORM
            run_name = timestr

        ## Check that runName is not already used in the database.
        ## Error page is showed if runName is already  defined
        if (RunProcess.objects.filter(runName = run_name)).exists():
            if RunProcess.objects.filter(runName = run_name, state__runStateName__exact ='Pre-Recorded'):
                ## Delete the Sample Sheet file and the row in database
                delete_run = RunProcess.objects.get(runName = run_name, state__runStateName__exact ='Pre-Recorded')
                sample_sheet_file = delete_run.get_sample_file()
                full_path_sample_sheet_file = os.path.join(settings.MEDIA_ROOT, sample_sheet_file)
                os.remove(full_path_sample_sheet_file)
                delete_run.delete()
            else:
                # delete sample sheet file
                os.remove(stored_file)
                return render (request,'iSkyLIMS_wetlab/error_page.html',
                    {'content':['Run Name is already used. ',
                        'Run Name must be unique in database.',' ',
                        'ADVICE:','Change the value in the Sample Sheet  file ']})

        ## Fetch from the Sample Sheet file the projects included in
        ## the run and the user. Error page is showed if not project/description
        ## colunms are found
        project_list=get_projects_in_run(stored_file)

        if len (project_list) == 0 :
            ## delete sample sheet file
            fs.delete(file_name)
            return render (request,'iSkyLIMS_wetlab/error_page.html',
                {'content':['Sample Sheet does not contain "Sample project" and/or "Description" fields',
                    '','ADVICE:','Check that csv file generated by Illumina Experient Manager (IEM) includes these columns']})

        ## Check if the projects are already defined on database.
        ## Error page is showed if projects are already defined on database

        project_already_defined=[]
        for key, val  in project_list.items():
            # check if project was already saved in database in Not Started State.
            # if found delete the projects, because the previous attempt to complete the run was unsuccessful
            if ( Projects.objects.filter(projectName__icontains = key).exists()):
                if ( Projects.objects.filter(projectName__icontains = key, runprocess_id__state__runStateName = 'Pre-Recorded').exists()):
                    delete_project = Projects.objects.get(projectName__icontains = key , runprocess_id__state__runStateName = 'Pre-Recorded')
                    delete_project.delete()
                else:
                    project_already_defined.append(key)
        if (len(project_already_defined)>0):
            if (len(project_already_defined)>1):
                head_text='The following projects are already defined in database:'
            else:
                head_text='The following project is already defined in database:'
            ## convert the list into string to display the user names on error page
            display_project= '  '.join(project_already_defined)
            ## delete sample sheet file before showing the error page
            fs.delete(file_name)
            return render (request,'iSkyLIMS_wetlab/error_page.html',
                {'content':[ head_text,'', display_project,'',
                    'Project names must be unique','', 'ADVICE:',
                    'Edit the Sample Sheet file to correct this error']})
        ##Once the information looks good. it will be stores in runProcess and projects table

        ## store data in runProcess table, run is in pre-recorded state
        center_requested_id = Profile.objects.get(profileUserID = request.user).profileCenter.id
        center_requested_by = Center.objects.get(pk = center_requested_id)
        run_proc_data = RunProcess(runName=run_name,sampleSheet= file_name,
                                state = RunStates.objects.get(runStateName__exact = 'Pre-Recorded'),
                                centerRequestedBy = center_requested_by)
        run_proc_data.save()
        experiment_name = '' if run_name == timestr else run_name

        ## create new project tables based on the project involved in the run and
        ## include the project information in projects variable to build the new FORM

        run_info_values ={}
        run_info_values['experiment_name'] = experiment_name
        run_info_values['index_library_name'] = index_library_name
        for key, val  in project_list.items():
            if User.objects.filter(username__exact = val).exists():
                userid = User.objects.get(username__exact = val)
            else:
                userid = None
            p_data = Projects(runprocess_id=RunProcess.objects.get(runName =run_name),
                            projectName=key, user_id=userid)
            p_data.save()
            projects.append([key, val])
        run_info_values['projects_user'] = projects
        run_info_values['runname']= run_name
        ## Get the list of the library kit used (libraryKit)
        used_libraries = []
        list_libraries = BaseSpaceLibraryName.objects.order_by().values_list('libraryName', flat=True)
        run_info_values['used_libraryKit'] =  list_libraries

        user_names = []
        all_users = User.objects.all()
        for user in all_users :
            user_names.append(user.username)
        run_info_values['aval_users'] =  user_names
        ## displays the list of projects and the user names found on Sample Sheet
        return render(request, 'iSkyLIMS_wetlab/CreateNextSeqRun.html', {'get_user_names': run_info_values })

    ## SECOND STEP in collecting data from the NextSeq run. Confirmation /modification of data included in Sample Sheet
    elif request.method=='POST' and (request.POST['action']=='displayResult'):
        experiment_name = request.POST['experimentname']
        run_index_library_name = request.POST['runindexlibraryname']
        run_name= request.POST['runname']
        projects=request.POST.getlist('project')
        user_name=request.POST.getlist('username')
        library_kit=request.POST.getlist('libraryKit')
        project_index_kit=request.POST.getlist('projectindexlibraryname')

        ## get the sample sheet used in the run. return error if run already exists
        if not RunProcess.objects.filter (runName__exact = run_name).exists():
            return render (
                request, 'iSkyLIMS_wetlab/error_page.html',
                {'content':['You get this error page because you use the back Buttom'
                ' to return to previous page where asking for library kit name',
                'To upload again the shample sheet, use the "Upload the Run" option from the top menu']})
        run_p = RunProcess.objects.get(runName__exact = run_name)
        s_file=run_p.get_sample_file()
        ## get the different type of library kit used in the run and
        ## convert the sample sheet into Base Space. Number of converted
        ## file will be the same as the number of different lybraries use in the run
        library={}
        bs_file={}
        results=[]

        in_file = os.path.join(settings.MEDIA_ROOT,s_file)
        # Set unique Sample_ID in the sample sheet
        index_file = os.path.join(settings.MEDIA_ROOT,'wetlab', 'index_file')
        create_unique_sample_id_values (in_file, index_file)
        # create the projects/users to update sample sheet
        user_names_in_projects ={}
        for p_index in range(len(projects)):
            user_names_in_projects[projects[p_index]] = user_name[p_index]

        set_user_names_in_sample_sheet (in_file, user_names_in_projects)
        ## build the project list for each project_library kit
        for x in range(len(project_index_kit)):
            if project_index_kit[x] in library :
                library[project_index_kit[x]].append(projects[x])
            else:
                library[project_index_kit[x]]= [projects[x]]
        ## convert the sample sheet to base space format and have different files according the library kit

        for key, value in library.items():
            lib_kit_file =key.replace(' ', '_')
            library_file = sample_sheet_map_basespace(in_file, key, lib_kit_file, value,'Plate96')
            if library_file == 'ERROR':
                # deleting the sample sheet file
                os.remove(in_file)
                # Deleting projects related to the shample sheet
                for p in range(len( projects)):
                    my_project = projects [p]
                    delete_proj=Projects.objects.get(projectName = my_project)
                    delete_proj.delete()
                # delete the run used when uploading the sample sheet
                run_p.delete()
                # show the error page
                return render (
                    request,'iSkyLIMS_wetlab/error_page.html',
                    {'content':[ 'The information on  the Library kit ', key,
                    ' For the project ', value,
                    'Does not meet the requirements to perform the conversion to import to Base Space',
                    'ADVICE', 'Check the sample sheet that was uploaded ']})
            else:
                bs_file[key] = library_file
                results.append([key, bs_file[key]])

        ## save the project information on database

        for p in range(len( projects)):
            my_project = projects [p]
            my_name = user_name[p]
            my_libkit = library_kit[p]
            library_kit_id = BaseSpaceLibraryName.objects.get(libraryName__exact = library_kit[p])
            update_info_proj=Projects.objects.get(projectName = my_project)
            update_info_proj.libraryKit=project_index_kit[p]
            update_info_proj.baseSpaceFile=bs_file[project_index_kit[p]]
            update_info_proj.LibraryKit_id = library_kit_id
            update_info_proj.user_id = User.objects.get(username__exact = user_name[p])
            update_info_proj.save()
        results.append(['runname', experiment_name])
        ## save the sample sheet file under tmp/recorded to be processed when run folder was created
        subfolder_name=str(run_p.id)

        temp_directory = os.path.join(settings.MEDIA_ROOT , wetlab_config.RUN_TEMP_DIRECTORY_RECORDED, subfolder_name)
        os.mkdir(temp_directory)
        # set group writing permission to the temporary directory
        os.chmod(temp_directory, 0o774)
        #os.mkdir(os.path.join(settings.MEDIA_ROOT, 'wetlab/tmp/recorded', subfolder_name ))
        sample_sheet_copy= os.path.join(temp_directory, 'samplesheet.csv' )
        shutil.copy(in_file,sample_sheet_copy)
        # set the group write permission to the Sample Sheet File
        os.chmod(sample_sheet_copy, 0o664)
        # update the sample sheet with the experiment name
        if run_name != experiment_name :
            update_sample_sheet (in_file, experiment_name)
        ## update the Experiment name and the state of the run to 'Recorded'
        run_p.runName = experiment_name
        run_p.index_library = run_index_library_name
        run_p.save()
        run_p.set_run_state ('Recorded')

        return render (request, 'iSkyLIMS_wetlab/CreateNextSeqRun.html', {'completed_form':results})

    return render(request, 'iSkyLIMS_wetlab/CreateNextSeqRun.html')

@login_required
def add_basespace_library (request):
    '''
    Description:
        The function is called from web, having 2 main parts:
            - User form with the information to add a new Basespace library
            - Result information as response of user submit
        Save a new basespace library name in database if it is not already defined.
    Input:
        request     # contains the request dictionary sent by django
    Variables:
        basespace_library_information ={} # returned dictionary with the information
                                to include in the web page
        basespace_library_objects # contains the object list of the basespace model
        basespace_library = [] # It is a list containing the Basespces Library names
        new_basespace_library_name # contain the new library name enter by user form
        library     # it is the new LibraryKit object
        l_kit       # is the iter variable for basespace_library_objects
    Return:
        Return the different information depending on the execution:
        -- Error page in case the library already exists.
        -- library_kit_information with :
            -- ['libraries']
            ---['new_basespace_library'] in case a new basespace library was added.
    '''

    libraries_information ={}
    basespace_library_information ={}
    basespace_library = []

    basespace_library_objects = BaseSpaceLibraryName.objects.all()
    if len(basespace_library_objects) >0 :
        for l_kit in basespace_library_objects :
            basespace_library.append(l_kit.libraryName)

    if request.method == 'POST' and request.POST['action'] == 'addNewBasespaceLibrary':
        new_basespace_library_name = request.POST['newBasespaceLibrary']

        ## Check that library kit is not already defined in database
        if BaseSpaceLibraryName.objects.filter(libraryName__icontains = new_basespace_library_name).exists():
            return render (request, 'iSkyLIMS_wetlab/error_page.html', {'content':['The Library Kit ', new_basespace_library_name, 'is already defined on the system']})

        basespace_library_information['new_basespace_library'] = new_basespace_library_name
        basespace_library.append(new_basespace_library_name)
        #save the new library on database
        b_library = BaseSpaceLibraryName(libraryName= new_basespace_library_name)
        b_library.save()

    basespace_library_information ['libraries'] = basespace_library
    return render(request,'iSkyLIMS_wetlab/AddBasespaceLibrary.html',{'list_of_libraries': basespace_library_information})

@login_required
def add_index_library (request):
    #get the list of the already loaded index library to be displayed
    '''
    Description:
        The function is called from web, having 2 main parts:
            - User form with the information to add a new library
            - Result information as response of user submit

    Input:
        request     # contains the request dictionary sent by django
    Variables:
        index_libraries_information     # returned dictionary with the information
                                        to include in the web page
        index_library_objects    #  contains the object list of the IndexLibraryKit model
        index_library_names     # It is a list containing the Index Library Kits names
        index_to_store      # contains the index (I7/I5) values that are stored in database
                            the same variable is used for the interaction for library_index

        library     # it is the new IndexLibraryKit object
        library_settings # settings values returned by
        l_kit       # is the iteration variable for index_library_objects
        lib_settings_to_store # is the new IndexLibraryKit object used to store
                        the information into database

        index_library_file      # contains the file provider by user in the form
        fs_index_lib    # file system index library object to store the input file
        saved_file      # contain the full path name, where the user file have been
                        stored in the server

    Constants:
        LIBRARY_KITS_DIRECTORY
        LIBRARY_MAXIMUM_SIZE
        MEDIA_ROOT
    Functions:
        in utils.library_kits :
            -- check_index_library_file_format(saved_file)     # for checking
                            the number of index in the input file
            -- getting_index_library_name(saved_file) # gets the library name
            -- get_library_settings(saved_file) # gets the settings values
                            from the input file
            -- get_index_values(saved_file)     # gets the index value

    Return:
         Return the different information depending on the execution:
        -- Error page in case of:
            -- Uploaded file is bigger than the LIBRARY_MAXIMUM_SIZE value
            -- file uploaded does not have the right format
            -- the library already exists.
        -- library_kit_information with :
            -- ['libraries']
            ---['new_library_kit'] in case a new library kit was added
    '''
    index_libraries_information ={}
    index_library_names = []

    index_library_objects = IndexLibraryKit.objects.all()
    if len(index_library_objects) > 0 :
        for l_index in index_library_objects :
            index_library_names.append([l_index.id, l_index.indexLibraryName])

    if request.method == 'POST' and request.POST['action'] == 'addNewIndexLibraryFile':
        ## fetch the file from user form and  build the file name  including
        ## the date and time on now to store in database
        index_library_file = request.FILES['newIndexLibraryFile']
        split_filename=re.search('(.*)(\.\w+$)',index_library_file.name)
        f_name = split_filename[1]
        f_extension = split_filename[2]
        fs_index_lib = FileSystemStorage()
        timestr = time.strftime("%Y%m%d-%H%M%S")

        ## using the MEDIA_ROOT variable defined on settings to upload the file
        file_name=os.path.join(wetlab_config.LIBRARY_KITS_DIRECTORY ,  str(f_name + '_' +timestr + f_extension))
        filename = fs_index_lib.save(file_name,  index_library_file)
        saved_file = os.path.join(settings.MEDIA_ROOT, file_name)

        ## check the file is not bigger that maximum allowed size file for index library
        file_stat = os.stat(saved_file)
        if file_stat.st_size > int(wetlab_config.LIBRARY_MAXIMUM_SIZE) :
            # removing the uploaded file
            os.remove(saved_file)
            return render (request, 'iSkyLIMS_wetlab/error_page.html',
                           {'content':['The Index Library Kit file ', split_filename[0],
                                       'exceed from the maximum allowed size']})
        uploaded_file_url = fs_index_lib.url(filename)

        ## check if user file has the  right format
        if not check_index_library_file_format(saved_file):
            ## removing the uploaded file
            os.remove(saved_file)
            return render (request, 'iSkyLIMS_wetlab/error_page.html',
                           {'content':['The Index Library Kit file', split_filename[0],
                                       'does not have the right format']})

        ## get the libary name to check if it is already defined
        library_name = getting_index_library_name(saved_file)
        if library_name == '' :
            # removing the uploaded file
            os.remove(saved_file)
            return render (request, 'iSkyLIMS_wetlab/error_page.html',
                           {'content':['The Index Library Kit file', split_filename[0],
                                       'does not contain the library name']})
        # check if library name is already defined on database
        if IndexLibraryKit.objects.filter (indexLibraryName__exact = library_name).exists():
            # removing the uploaded file
            os.remove(saved_file)
            return render (request, 'iSkyLIMS_wetlab/error_page.html',
                           {'content':['The Library Kit Name ', library_name,
                                       'is already defined on iSkyLIMS']})
        # Get the library settings included in the file
        library_settings = get_library_settings(saved_file)


        # saving library settings into database
        if len(library_settings['adapters']) == 1:
            adapter_2 = ''
        else :
            adapter_2 = library_settings['adapters'][1]
        lib_settings_to_store = IndexLibraryKit(indexLibraryName = library_settings['name'],
                                    version =  library_settings ['version'],
                                    plateExtension = library_settings['plate_extension'] ,
                                    adapter1 = library_settings['adapters'][0],
                                    adapter2 = adapter_2, indexLibraryFile = file_name)
        lib_settings_to_store.save()

        ## get the index name and index bases for the library
        library_index = get_index_values(saved_file)
        # saving index values into database
        for row in library_index :
            index_to_store = IndexLibraryValues(indexLibraryKit_id = lib_settings_to_store,
                                    defaultWell = row[0], index_7 = row[1],
                                    i_7_seq = row[2], index_5 = row[3],
                                    i_5_seq = row[4])
            index_to_store.save()

        index_libraries_information['new_index_library'] = library_settings['name']
        index_libraries_information ['index_libraries'] = index_library_names

        return render (request, 'iSkyLIMS_wetlab/AddIndexLibrary.html',{'index_library_info': index_libraries_information })
    else:
        index_libraries_information ['index_libraries'] = index_library_names
        return render (request, 'iSkyLIMS_wetlab/AddIndexLibrary.html',{'list_of_index_libraries': index_libraries_information })



@login_required
def search_run (request):
    '''
    Description:
        The function is called from web, having 2 main parts:
            - User form with the information to search runs
            - Result information can be :
                - list of the matched runs
                - run information in case that only 1 match is found
    Input:
        request     # contains the request dictionary sent by django
    Imports:
        Machines and Platform are imported from iSkyLIMS_drylab.models
            for filtering runs based on the platform
    Functions:
        get_information_run() # Collects information about one run
    Variables:
        User inputs from search options
            run_name        # string characters to find in the run name
            platform_name   # platform name filter
            run_state       # state of the run
            start_date      # filter of starting date of the runs
            end_date        # filter for the end of the runs
        available_platforms # contains the list of platform defined in
                            # iSkyLIMS.models.Platform
        machine_list        # list of machines to filter on the matches runs
        platforms           # contain the object from iSkyLIMS.models.Platform
        platform_name       # has the platform get from user form

        runs_found          # runProcess object that contains the result query
                            # it is updated with the user form conditions
        r_data_display      # contains the information to display about the run
        run_list            # contains the run list that mathches te user conditions
    Return:
        Return the different information depending on the execution:
        -- Error page in case no run is founded on the matching conditions.
        -- SearchRun.html is returned with one of the following information :
            -- r_data_display   # in case that only one run is matched
            ---run_list         # in case several run matches the user conditions.

    '''
    # check user privileges
    if request.user.is_authenticated:
        try:
            groups = Group.objects.get(name=wetlab_config.WETLAB_MANAGER)
            if groups not in request.user.groups.all():
                allowed_all_runs = False
               #return render (request,'iSkyLIMS_wetlab/error_page.html', {'content':['You do have the enough privileges to see this page ','Contact with your administrator .']})
            else:
                allowed_all_runs = True
        except:
            return render (request,'iSkyLIMS_wetlab/error_page.html', {'content':['You do have the enough privileges to see this page ','Contact with your administrator .']})
    else:
        #redirect to login webpage
        return redirect ('/accounts/login')
    #############################################################
    ## Search for runs that fullfil the input values
    #############################################################
    if request.method == 'POST' and (request.POST['action'] == 'runsearch'):
        run_name = request.POST['runname']
        start_date = request.POST['startdate']
        end_date = request.POST['enddate']
        run_state = request.POST['runstate']
        platform_name = request.POST['platform']
        # check that some values are in the request if not return the form
        if run_name == '' and start_date == '' and end_date == '' and run_state == '' and platform_name == '' :
            return render(request, 'iSkyLIMS_wetlab/SearchRun.html')

        ### check the right format of start and end date
        if start_date != '':
            try:
                datetime.datetime.strptime(start_date, '%Y-%m-%d')
            except:
                return render (request,'iSkyLIMS_wetlab/error_page.html',
                            {'content':['The format for the "Start Date Search" Field is incorrect ',
                            'ADVICE:', 'Use the format  (DD-MM-YYYY)']})
        if end_date != '':
            try:
                datetime.datetime.strptime(end_date, '%Y-%m-%d')
            except:
                return render (request,'iSkyLIMS_wetlab/error_page.html',
                            {'content':['The format for the "End Date Search" Field is incorrect ',
                            'ADVICE:', 'Use the format  (DD-MM-YYYY)']})
        ### Get all the available runs to start the filtering
        if allowed_all_runs :
            runs_found=RunProcess.objects.all().order_by('runName')
        else:

            user_projects = Projects.objects.filter(user_id__exact = request.user.id)
            run_list =[]
            for user_project in user_projects :
                run_list.append(user_project.runprocess_id.id)
            if RunProcess.objects.filter(pk__in = run_list).exists():
                runs_found = RunProcess.objects.filter(pk__in = run_list)
            else:
                return render (request,'iSkyLIMS_wetlab/error_page.html',
                                    {'content':['There are not run where ',
                                    request.user.username , 'was involved' ]})

        ### Get runs when run name is not empty
        if run_name !='':
            if (RunProcess.objects.filter(runName__exact =run_name).exists()):
                run_name_found=RunProcess.objects.filter(runName__exact =run_name)
                if (len(run_name_found)>1):
                    return render (request,'iSkyLIMS_wetlab/error_page.html', {'content':['Too many matches found when searching for the run name ', run_name ,
                                                                    'ADVICE:', 'Select additional filter to find the run that you are looking for']})
                r_data_display= get_information_run(run_name_found[0])
                return render(request, 'iSkyLIMS_wetlab/SearchRun.html', {'display_one_run': r_data_display })
            if (runs_found.filter(runName__icontains =run_name).exists()):
                runs_found=runs_found.filter(runName__icontains =run_name).order_by('runName')
            else:
                return render (request,'iSkyLIMS_wetlab/error_page.html',
                                    {'content':['No matches have been found for the run name ',
                                     run_name ]})
        if platform_name != '' :
            from iSkyLIMS_drylab.models import Machines, Platform
            if Machines.objects.filter(platformID__exact = Platform.objects.get(platformName__exact = platform_name)).exists() :
                machine_list = Machines.objects.filter(platformID__exact = Platform.objects.get(platformName__exact = platform_name))
                if runs_found.filter(sequencerModel__in = machine_list).exists() :
                    runs_found = runs_found.filter(sequencerModel__in = machine_list)
                else:
                    return render (request,'iSkyLIMS_wetlab/error_page.html',
                                    {'content':['No matches have been found for the platform ',
                                     platform_name ]})
            else:
                return render (request,'iSkyLIMS_wetlab/error_page.html',
                                {'content':['No matches have been found for the platform ', platform_name ]})

        ### Check if state is not empty
        if run_state != '':
            s_state = RunStates.objects.get(runStateName__exact = run_state)
            if runs_found.filter(state__runStateName__exact = s_state).exists():
                runs_found = runs_found.filter(state__runStateName__exact = s_state).order_by('runName')
            else :
                return render (request,'iSkyLIMS_wetlab/error_page.html', {'content':['No matches have been found for the run name ', run_name ,
                                                                    'and the state', run_state ]})
        ### Check if start_date is not empty
        if start_date !='' and end_date != '':

            if runs_found.filter(run_date__range=(start_date, end_date)).exists():
                 runs_found = runs_found.filter(run_date__range=(start_date, end_date))
            else:
                return render (request,'iSkyLIMS_wetlab/error_page.html', {'content':['There are no runs containing ', run_name,
                                        ' created between ', start_date, 'and the ', end_date]})
        if start_date !='' and end_date == '':
            if runs_found.filter(run_date__gte = start_date).exists():
                 runs_found = runs_found.filter(run_date__gte = start_date)
            else:
                return render (request,'iSkyLIMS_wetlab/error_page.html', {'content':['There are no Runs containing ', run_name,
                                        ' starting from', start_date]})
        if start_date =='' and end_date != '':
            if runs_found.filter(run_date__lte = end_date).exists():
                 runs_found = runs_found.filter(run_date__lte = end_date)
            else:
                return render (request,'iSkyLIMS_wetlab/error_page.html', {'content':['There are no Runs containing ', run_name,
                                        ' finish before ', end_date]})
        #If only 1 run mathes the user conditions, then get the project information

        if (len(runs_found)== 1) :
            return redirect ('display_run', run_id=runs_found[0].pk)

        else:
            ## collect the list of run that matches the run date
            run_list=[]
            for i in range(len(runs_found)):
                run_list.append([runs_found[i],runs_found[i].id])
            return render(request, 'iSkyLIMS_wetlab/SearchRun.html', {'display_run_list': run_list })
    else:
        available_platforms = []
        available_machines = []
        from iSkyLIMS_drylab.models import Platform, Machines

        available_states = []

        run_states = RunStates.objects.all()
        for state in run_states :
            available_states.append(state.runStateName)

        platforms = Platform.objects.all()
        for platform in platforms :
            available_platforms.append(platform.get_platform_name())
        machines = Machines.objects.all()
        for machine in machines :
            available_machines.append(machine.get_machine_name())


        return render(request, 'iSkyLIMS_wetlab/SearchRun.html', {'platforms': available_platforms,'machines':available_machines,'run_states':available_states})

@login_required
def search_project (request):
    '''
    Description:
        The function is called from web, having 2 main parts:
            - User form with the information to search projects
            - Result information can be :
                - list of the matched projects
                - project information in case that only 1 match is found

    Input:
        request     # contains the request dictionary sent by django
    Imports:
        Machines and Platform are imported from iSkyLIMS_drylab.models
            for filtering runs based on the platform
    Variables:

        User inputs from search options
            project_name    # string characters to find in the project name
            platform_name   # platform name filter
            start_date      # filter of starting date of the project
            end_date        # filter for the end of the project



        available_platforms # contains the list of platform defined in
                            # iSkyLIMS.models.Platform
        machine_list        # list of machines to filter on the matches runs
        platforms           # contain the object from iSkyLIMS.models.Platform
        platform_name       # has the platform get from user form

        project_found       # Projects object that contains the result query
                            # it is updated with the user form conditions
        r_data_display      # contains the information to display about the project
        run_list            # contains the project list that mathches te user conditions
        run_process_ids     # contains the runs ids which have the platflorm
                              value enter by user

    Return:
        Return the different information depending on the execution:
        -- Error page in case no run is founded on the matching conditions.
        -- SearchRun.html is returned with one of the following information :
            -- r_data_display   # in case that only one run is matched
            ---run_list         # in case several run matches the user conditions.

    '''
    if request.method=='POST' and (request.POST['action']=='searchproject'):
        project_name=request.POST['projectname']
        start_date=request.POST['startdate']
        end_date=request.POST['enddate']
        user_name = request.POST['username']
        platform_name = request.POST['platform']
        run_state = request.POST['runstate']
        run_process_ids = []
        # check that some values are in the request if not return the form
        if project_name == '' and start_date == '' and end_date == '' and user_name =='' and platform_name == '' and run_state == '':
            available_platforms = get_available_platform()
            available_states = get_available_run_state()
            return render(request, 'iSkyLIMS_wetlab/SearchProject.html', {'platforms': available_platforms,'run_states':available_states})

        if user_name !=''  and len(user_name) <5 :
             return render (request,'iSkyLIMS_wetlab/error_page.html',
                        {'content':['The user name must contains at least 5 caracters ',
                                    'ADVICE:', 'write the full user name to get a better match']})
        ### check the right format of start and end date
        if start_date != '':
            try:
                datetime.datetime.strptime(start_date, '%Y-%m-%d')
            except:
                return render (request,'iSkyLIMS_wetlab/error_page.html',
                        {'content':['The format for the "Start Date Search" Field is incorrect ',
                                    'ADVICE:', 'Use the format  (DD-MM-YYYY)']})
        if end_date != '':
            try:
                datetime.datetime.strptime(end_date, '%Y-%m-%d')
            except:
                return render (request,'iSkyLIMS_wetlab/error_page.html',
                        {'content':['The format for the "End Date Search" Field is incorrect ',
                                    'ADVICE:', 'Use the format  (DD-MM-YYYY)']})
        ### Get projects when project name is not empty
        if project_name != '' :
            if Projects.objects.filter(projectName__exact = project_name).exists():
                project_id = Projects.objects.get (projectName__exact = project_name).id
                project_found_id = Projects.objects.get(pk=project_id)
                p_data_display  = get_information_project(project_found_id, request)
                return render(request, 'iSkyLIMS_wetlab/SearchProject.html',
                        {'display_one_project': p_data_display })
            if  Projects.objects.filter (projectName__contains = project_name).exists():
                projects_found = Projects.objects.filter (projectName__contains = project_name)
            else:
                return render (request,'iSkyLIMS_wetlab/error_page.html',
                        {'content':['No Project found with the string , ', project_name ]})
        ### if there is no project name, then get all which will be filtered by other conditions set by user
        #
        if project_name == '':
            projects_found = Projects.objects.all()
        if platform_name != '':
            from iSkyLIMS_drylab.models import Machines, Platform
            if Machines.objects.filter(platformID__platformName__exact = platform_name).exists() :
                machine_list = Machines.objects.filter(platformID__platformName__exact = platform_name)

                if RunProcess.objects.filter(sequencerModel__in = machine_list).exists() :
                    runs_found = RunProcess.objects.filter(sequencerModel__in = machine_list)
                    for run in runs_found :
                        run_process_ids.append(run.id)
                    if projects_found.filter(runprocess_id__in = run_process_ids).exists():
                        projects_found = projects_found.filter(runprocess_id__in = run_process_ids)
                    else:
                        return render (request,'iSkyLIMS_wetlab/error_page.html',
                                    {'content':['No matches have been found for the platform ',
                                     platform_name ]})
                else:
                    return render (request,'iSkyLIMS_wetlab/error_page.html',
                                    {'content':['No matches have been found for the platform ',
                                     platform_name ]})
            else:
                return render (request,'iSkyLIMS_wetlab/error_page.html',
                                {'content':['No matches have been found for the platform ', platform_name ]})

                # check if user name is not empty
        if user_name != '':
            if User.objects.filter(username__icontains = user_name).exists():
                r_name_id = User.objects.get(username__icontains = user_name).id
                if projects_found.filter(user_id__exact =r_name_id).exists():
                    projects_found = projects_found.filter(user_id__exact =r_name_id)
                else:
                     return render (request,'iSkyLIMS_wetlab/error_page.html', {'content':['The Project found does not belong to the user, ', user_name ]})
            else:
                return render (request,'iSkyLIMS_wetlab/error_page.html', {'content':['The Project found does not belong to the user, ', user_name ]})
        if (run_state !='' ):
            if projects_found.filter(runprocess_id__state__runStateName__exact = run_state):
                projects_found = projects_found.filter(runprocess_id__state__runStateName__exact = run_state)
            else :
                return render (request,'iSkyLIMS_wetlab/error_page.html', {'content':['There ane not Projects containing ', project_name,
                                               'in state', project_state ]})
        if start_date !='' and end_date != '':

            if projects_found.filter(project_run_date__range=(start_date, end_date)).exists():
                 projects_found = projects_found.filter(project_run_date__range=(start_date, end_date))
            else:
                return render (request,'iSkyLIMS_wetlab/error_page.html', {'content':['There are no Projects containing ', project_name,
                                        ' created between ', start_date, 'and the ', end_date]})
        if start_date !='' and end_date == '':
            if projects_found.filter(project_run_date__gte = start_date).exists():
                 projects_found = projects_found.filter(project_run_date__gte = start_date)
                 #
            else:
                return render (request,'iSkyLIMS_wetlab/error_page.html', {'content':['There are no Projects containing ', project_name,
                                        ' starting from', start_date]})
        if start_date =='' and end_date != '':
            if projects_found.filter(project_run_date__lte = end_date).exists():
                 projects_found = projects_found.filter(project_run_date__lte = end_date)
            else:
                return render (request,'iSkyLIMS_wetlab/error_page.html', {'content':['There are no Projects containing ', project_name,
                                        ' finish before ', end_date]})
        #If only 1 project mathes the user conditions, then get the project information

        if len (projects_found) == 1:
            project_id = projects_found[0].id
            project_found_id = Projects.objects.get(pk=project_id)
            p_data_display  = get_information_project(project_found_id, request)
            return render(request, 'iSkyLIMS_wetlab/SearchProject.html', {'display_one_project': p_data_display })
        else :
            # Display a list with all projects that matches the conditions
            project_list_dict = {}
            project_list = []
            for project in projects_found :
                p_name = project.get_project_name()
                p_name_id = project.id
                project_list.append([p_name, p_name_id])
            project_list_dict ['projects'] = project_list
            return render(request, 'iSkyLIMS_wetlab/SearchProject.html', {'display_project_list': project_list_dict })

    else:
        available_platforms = get_available_platform()
        available_states = get_available_run_state()
        return render(request, 'iSkyLIMS_wetlab/SearchProject.html', {'platforms': available_platforms,'run_states':available_states})





@login_required
def search_sample (request):
    '''
    Description:
        The function is called from web, having 2 main parts:
            - User form with the information to search samples
            - Result information can be :
                - list of the matched samples
                - sample information in case that only 1 match is found
    Input:
        request     # contains the request dictionary sent by django
    Variables:

        User inputs from search options
            sample_name     # string characters to find in the project name
            start_date      # filter of starting date of the project
            end_date        # filter for the end of the project
            user_name       # name of user owner of the sample


        sample_found        # Sample object that contains the result query
                            # it is updated with the user form conditions
        project_id_list     # contains the a list of projects objects
                            owner of the enter used name for filtering
                            the previous matched samples
        sample_data_information # Contains all the sample information
                            to be displayed on the web page
        sample_list         # contains the sample list that mathches
                            the user conditions
    Return:
        Return the different information depending on the execution:
        -- Error page in case no sample is founded on the matching conditions.
        -- SearchSample.html is returned with one of the following information :
            -- sample_data_information   # in case that only one run is matched
            ---sample_list         # in case several run matches the user conditions.

    '''
    if request.method=='POST' and (request.POST['action']=='searchsample'):
        sample_name=request.POST['samplename']
        start_date=request.POST['startdate']
        end_date=request.POST['enddate']
        user_name = request.POST['username']

        # check that some values are in the request if not return the form
        if user_name == '' and start_date == '' and end_date == '' and sample_name =='':
            return render(request, 'iSkyLIMS_wetlab/SearchSample.html')

        if user_name !=''  and len(user_name) <5 :
             return render (request,'iSkyLIMS_wetlab/error_page.html',
                    {'content':['The user name must contains at least 5 caracters ',
                    'ADVICE:', 'write the full user name to get a better match']})
        ### check the right format of start and end date
        if start_date != '':
            try:
                datetime.datetime.strptime(start_date, '%Y-%m-%d')
            except:
                return render (request,'iSkyLIMS_wetlab/error_page.html',
                    {'content':['The format for the "Start Date Search" Field is incorrect ',
                    'ADVICE:', 'Use the format  (DD-MM-YYYY)']})
        if end_date != '':
            try:
                datetime.datetime.strptime(end_date, '%Y-%m-%d')
            except:
                return render (request,'iSkyLIMS_wetlab/error_page.html',
                    {'content':['The format for the "End Date Search" Field is incorrect ',
                     'ADVICE:', 'Use the format  (DD-MM-YYYY)']})
        ### Get projects when sample name is not empty
        if sample_name != '' :

            if SamplesInProject.objects.filter(sampleName__exact = sample_name).exists():
                sample_found = SamplesInProject.objects.filter(sampleName__exact = sample_name)
                if len(sample_found) == 1:
                    # get information from the sample found
                    ########################################
                    sample_data_information = get_info_sample (sample_found[0])
                    return render(request, 'iSkyLIMS_wetlab/SearchSample.html',{'display_one_sample': sample_data_information })
            elif SamplesInProject.objects.filter(sampleName__contains = sample_name).exists():
                sample_found = SamplesInProject.objects.filter(sampleName__contains = sample_name)
                #
            else:
                return render (request,'iSkyLIMS_wetlab/error_page.html',
                    {'content':['No sample found with the string , ', sample_name ]})

        ### if there is no project name, then get all which will be filtered by other conditions set by user
        #
        else :
            sample_found = SamplesInProject.objects.all()
        # Check the start and end date
        if start_date !='' and end_date != '':

            if sample_found.filter(generated_at__range=(start_date, end_date)).exists():
                 sample_found = sample_found.filter(generated_at__range=(start_date, end_date))
            else:
                return render (request,'iSkyLIMS_wetlab/error_page.html',
                        {'content':['There are no Projects containing ', sample_name,
                        ' created between ', start_date, 'and the ', end_date]})
        if start_date !='' and end_date == '':
            if sample_found.filter(generated_at__gte = start_date).exists():
                 sample_found = sample_found.filter(generated_at__gte = start_date)
            else:
                return render (request,'iSkyLIMS_wetlab/error_page.html',
                        {'content':['There are no Projects containing ', sample_name,
                                        ' starting from', start_date]})
        if start_date =='' and end_date != '':
            if sample_found.filter(generated_at__lte = end_date).exists():
                 sample_found = sample_found.filter(generated_at__lte = end_date)
            else:
                return render (request,'iSkyLIMS_wetlab/error_page.html',
                        {'content':['There are no Projects containing ', sample_name,
                         ' finish before ', end_date]})
                # check if user name is not empty
        if user_name != '':
            #
            if User.objects.filter(username__contains = user_name).exists():
                users = User.objects.filter (username__contains = user_name)
                if len(users) == 1:
                    user_id= users[0].id
                    project_id_list = Projects.objects.prefetch_related('user_id').filter(user_id = user_id)
                    sample_found = sample_found.filter(project_id__in = project_id_list)

                else:
                    text_error= 'There are too many users names containing ' + sample_name  + '  which match your query'
                    return render (request,'iSkyLIMS_wetlab/error_page.html',
                        {'content':[text_error, 'ADVICE:',
                        'Fill in the user name field the full name of the user' ]})

                #r_name_id = User.objects.get(username__icontains = user_name).id

            else:
                return render (request,'iSkyLIMS_wetlab/error_page.html',
                    {'content':['The samples found did not belong to the user, ', user_name ]})

        if len(sample_found) == 0:
            text_error = 'User ' + user_name +' does not have yet any samples'
            return render (request,'iSkyLIMS_wetlab/error_page.html',
                        {'content':[text_error,  'ADVICE:',
                        'Contact with your administrator to find out the reason for not matching any result' ]})
        if len(sample_found) == 1:
            sample_data_information = get_info_sample (sample_found[0])
            return render(request, 'iSkyLIMS_wetlab/SearchSample.html',
                            {'display_one_sample': sample_data_information })

        else:
            sample_list= {}
            s_list  = {}
            for sample in sample_found:
                sample_project =  sample.get_project_name()
                s_list [sample.id] = [[sample.sampleName, sample_project]]
            sample_list ['s_list'] = s_list

            #

            return render (request, 'iSkyLIMS_wetlab/SearchSample.html',
                                {'multiple_samples': sample_list})
    else:
    #
        return render(request, 'iSkyLIMS_wetlab/SearchSample.html')



@login_required
def display_run (request, run_id):
    # check user privileges
    if request.user.is_authenticated:
        try:
            groups = Group.objects.get(name = wetlab_config.WETLAB_MANAGER)
            if groups not in request.user.groups.all():
                # check if user is owner of the run
                if Projects.objects.filter(runprocess_id__exact = run_id).exists():
                    projects = Projects.objects.filter(runprocess_id__exact = run_id)
                    user_list =[]
                    for project in projects:
                        user_list.append(project.user_id.id)
                    if  not request.user.id in user_list :
                        return render (request,'iSkyLIMS_wetlab/error_page.html', {'content':['You do have the enough privileges to see this page ','Contact with your administrator .']})
                else:
                    return render (request,'iSkyLIMS_wetlab/error_page.html', {'content':['No matches have been found for the run  ']})

        except:
            return render (request,'iSkyLIMS_wetlab/error_page.html', {'content':['You do have the enough privileges to see this page ','Contact with your administrator .']})
    else:
        #redirect to login webpage
        return redirect ('/accounts/login')
    if (RunProcess.objects.filter(pk=run_id).exists()):
        run_name_found = RunProcess.objects.get(pk=run_id)
        r_data_display  = get_information_run(run_name_found)
        return render(request, 'iSkyLIMS_wetlab/SearchRun.html', {'display_one_run': r_data_display })
    else:
        return render (request,'iSkyLIMS_wetlab/error_page.html', {'content':['No matches have been found for the run  ']})

@login_required
def latest_run (request) :
    # check user privileges
    if request.user.is_authenticated:

        try:
            groups = Group.objects.get(name='WetlabManager')
            if groups not in request.user.groups.all():
                return render (request,'iSkyLIMS_wetlab/error_page.html', {'content':['You do have the enough privileges to see this page ','Contact with your administrator .']})
        except:
            return render (request,'iSkyLIMS_wetlab/error_page.html', {'content':['You do have the enough privileges to see this page ','Contact with your administrator .']})
    else:
        #redirect to login webpage
        return redirect ('/accounts/login')

    latest_run = RunProcess.objects.order_by('id').last()
    run_id = latest_run.id
    r_data_display  = get_information_run(latest_run)
    return render(request, 'iSkyLIMS_wetlab/SearchRun.html', {'display_one_run': r_data_display })

@login_required
def incompleted_runs (request) :
    # check user privileges
    if request.user.is_authenticated:
        try:
            groups = Group.objects.get(name='WetlabManager')
            if groups not in request.user.groups.all():
                return render (request,'iSkyLIMS_wetlab/error_page.html', {'content':['You do have the enough privileges to see this page ','Contact with your administrator .']})
        except:
            return render (request,'iSkyLIMS_wetlab/error_page.html', {'content':['You do have the enough privileges to see this page ','Contact with your administrator .']})
    else:
        #redirect to login webpage
        return redirect ('/accounts/login')
    if RunProcess.objects.all().exclude(state__runStateName = 'Completed').exists() :
        display_incomplete_run_list = {}
        unfinished_runs = RunProcess.objects.all().exclude(state__runStateName = 'Completed').order_by('runName')
        for run in unfinished_runs:
            display_incomplete_run_list[run.id] = [[run.runName, run.get_state()]]
    else:
        return render (request,'iSkyLIMS_wetlab/info_page.html', {'content':['There is no project in incompleted state' , 'All Runs are finished']})

    return render (request, 'iSkyLIMS_wetlab/incompletedRuns.html',{'display_incomplete_run_list':display_incomplete_run_list})





def check_user_access (request, project_found_id ) :

    groups = Group.objects.get(name = wetlab_config.WETLAB_MANAGER)
    # check if user belongs to WetlabManager . If true allow to see the page
    if groups not in request.user.groups.all():
        #check if project belongs to the same user as the one requesting the page
        if project_found_id.user_id.id != request.user.id :
           return False
    return True



@login_required
def display_project (request, project_id):

    if (Projects.objects.filter(pk=project_id).exists()):
        project_found_id = Projects.objects.get(pk=project_id)
        if request.user.is_authenticated:
            # check that user is allow to make the change
            allowed_access = check_user_access (request, project_found_id)
            if not allowed_access :
                return render (request,'iSkyLIMS_wetlab/error_page.html', {'content':['You do have the enough privileges to see this page ','Contact with your administrator .']})
        else:
            #redirect to login webpage
            return redirect ('/accounts/login')
        # Display the proyect information
        p_data_display  = get_information_project(project_found_id, request)
        return render(request, 'iSkyLIMS_wetlab/SearchProject.html', {'display_one_project': p_data_display })
    else:
        return render (request,'iSkyLIMS_wetlab/error_page.html', {'content':['No matches have been found for the project  ' ]})

@login_required
def display_sample (request, sample_id):
    '''
    Description:
        The function will check if the requested sample id exists, then
        it will call to get_info_sample function to collect all information
    Input:
        request     # contains the request dictionary sent by django
        sample_id   # contains the sample id to display the information
    Variables:
        sample_data_information ={} # returned dictionary with the information
                                to include in the web page
        sample_found_id  # contains the object for the sample id
    Functions:
        get_info_sample (sample_found_id)
    Return:
        Return the different information depending on the execution:
        -- Error page in case the sample id in the request does not exists.
        -- sample_data_information with the information collected by get_info_sample()
    '''

    if (SamplesInProject.objects.filter(pk=sample_id).exists()):
        sample_found_id = SamplesInProject.objects.get(pk=sample_id)
        sample_data_information = get_info_sample (sample_found_id)
        return render(request, 'iSkyLIMS_wetlab/SearchSample.html',{'display_one_sample': sample_data_information })
    else:
        return render (request,'iSkyLIMS_wetlab/error_page.html', {'content':['No matches have been found for the sample  ' ]})






@login_required
def display_index_library (request, index_library_id):
    if (IndexLibraryKit.objects.filter(pk=index_library_id).exists()) :

        index_library_dict = index_library_information (index_library_id)
        if index_library_dict != False:
            return render (request, 'iSkyLIMS_wetlab/DisplayIndexLibrary.html', {'display_one_index_library': index_library_dict})
        else:
            return render (request,'iSkyLIMS_wetlab/error_page.html', {'content':['There are recorded information for the index library for ',  index_library_id]})

    else:
        return render (request,'iSkyLIMS_wetlab/error_page.html', {'content':['No matches have been found for the index Library  ' ]})




@login_required
def search_index_library (request):

    if request.method == 'POST' and (request.POST['action'] == 'searchindexlibrary') :
        index_library_name=request.POST['indexlibraryname']
        adapter_1=request.POST['adapter1']
        adapter_2=request.POST['adapter2']
        index_name=request.POST['indexname']
        index_base=request.POST['indexbase']
        start_date=request.POST['startdate']
        end_date=request.POST['enddate']

        # check that some values are in the request if not return the form
        if index_library_name == '' and start_date == '' and end_date == '' and adapter_1 =='' and adapter_2 == '' and index_name == '' and index_base == '' :
            return render(request, 'iSkyLIMS_wetlab/searchIndexLibrary.html')

        if index_base !=''  and len(index_base) < 6 :
             return render (request,'iSkyLIMS_wetlab/error_page.html', {'content':['Index Sequence must contains at leat 6  caracters ']})
        ### check the right format of start and end date
        if start_date != '':
            try:
                datetime.datetime.strptime(start_date, '%Y-%m-%d')
            except:
                return render (request,'iSkyLIMS_wetlab/error_page.html', {'content':['The format for the "Start Date Search" Field is incorrect ',
                                                                    'ADVICE:', 'Use the format  (DD-MM-YYYY)']})
        if end_date != '':
            try:
                datetime.datetime.strptime(end_date, '%Y-%m-%d')
            except:
                return render (request,'iSkyLIMS_wetlab/error_page.html', {'content':['The format for the "End Date Search" Field is incorrect ',
                                                                    'ADVICE:', 'Use the format  (DD-MM-YYYY)']})

        index_library_found = IndexLibraryKit.objects.all()
        if index_library_name != '':
            if index_library_found.filter(indexLibraryName__contains = index_library_name).exists():
                index_library_found = index_library_found.filter(indexLibraryName__contains = index_library_name)
                if len (index_library_found) == 1:
                    index_library_dict = index_library_information (index_library_found[0].id)
                    if index_library_dict != False:
                        return render (request, 'iSkyLIMS_wetlab/DisplayIndexLibrary.html', {'display_one_index_library': index_library_dict})
                    else:
                        return render (request,'iSkyLIMS_wetlab/error_page.html', {'content':['There are no recorded information for the index library for ',  index_library_id]})
        if adapter_1 != '':
            if index_library_found.filter(adapter1__contains =adapter_1).exists():
                index_library_found = index_library_found.filter(adapter1__contains =adapter_1)
            else:
                return render (request,'iSkyLIMS_wetlab/error_page.html', {'content':['There are no libraries contaning Adapter 1 ', adapter_1]})
        if adapter_2 != '':
            if index_library_found.filter(adapter1__contains =adapter_2).exists():
                index_library_found = index_library_found.filter(adapter2__contains =adapter_2)
            else:
                return render (request,'iSkyLIMS_wetlab/error_page.html', {'content':['There are no libraries contaning Adapter 2 ', adapter_2]})



        # Check the start and end date
        if start_date !='' and end_date != '':

            if index_library_found.filter(generatedat__range=(start_date, end_date)).exists():
                 index_library_found = index_library_found.filter(generatedat__range=(start_date, end_date))
            else:
                return render (request,'iSkyLIMS_wetlab/error_page.html', {'content':['There are no libraries ',
                                        ' created between ', start_date, 'and the ', end_date]})
        if start_date !='' and end_date == '':
            if index_library_found.filter(generatedat__gte = start_date).exists():
                 index_library_found = index_library_found.filter(generatedat__gte = start_date)
                 #
            else:
                return render (request,'iSkyLIMS_wetlab/error_page.html', {'content':['There are no libraries ',
                                        ' starting from', start_date]})
        if start_date =='' and end_date != '':
            if index_library_found.filter(generatedat__lte = end_date).exists():
                 index_library_found = index_library_found.filter(generatedat__lte = end_date)
            else:
                return render (request,'iSkyLIMS_wetlab/error_page.html', {'content':['There are no libraries ',
                                        ' finish before ', end_date]})

        if index_name != '':
            if IndexLibraryValues.objects.filter(indexName__exact =index_name).exists():
                index_name_list = IndexLibraryValues.objects.prefetch_related('indexLibraryKit_id').filter(indexName = index_name)
                index_library_found = index_library_found.filter(indexlibraryvalues__in = index_name_list)

                #index_library_found = index_library_found.filter(
            else:
                return render (request,'iSkyLIMS_wetlab/error_page.html', {'content':['There are no libraries contaning index_name ', index_name]})

        if index_base != '':
            if IndexLibraryValues.objects.filter(indexBase__exact =index_base).exists():
                index_base_list = IndexLibraryValues.objects.prefetch_related('indexLibraryKit_id').filter(indexBase = index_base)
                index_library_found = index_library_found.filter(indexlibraryvalues__in = index_base_list)
                #index_library_found = index_library_found.filter(
            else:
                return render (request,'iSkyLIMS_wetlab/error_page.html', {'content':['There are no libraries contaning Base Sequence ', index_base]})

        if len(index_library_found) == 1 :
            index_library_dict = index_library_information (index_library_found[0].id)
            if index_library_dict != False:
                return render (request, 'iSkyLIMS_wetlab/DisplayIndexLibrary.html', {'display_one_index_library': index_library_dict})
            else:
                return render (request,'iSkyLIMS_wetlab/error_page.html', {'content':['There are no recorded information for the index library for ',  index_library_id]})

        else:
            # generate the list with all library that matches conditions
            index_library_dict = {}
            index_values = []
            for index_library in index_library_found:
                values = []
                values.append(index_library.id)
                values.append(index_library.indexLibraryName)
                values.append(index_library.version)
                index_values.append(values)
            index_library_dict['index_values'] = index_values

            return render (request, 'iSkyLIMS_wetlab/searchIndexLibrary.html', {'display_list_index_library': index_library_dict})


    else:
        return render (request, 'iSkyLIMS_wetlab/searchIndexLibrary.html')


@login_required
def change_run_name (request, run_id):
    if RunProcess.objects.filter(pk=run_id).exists():
        run = RunProcess.objects.get(pk = run_id)
        if not request.user.is_authenticated :
            return redirect ('/accounts/login')
        # check if user is allow to make the change
        groups = Group.objects.get(name='WetlabManager')
        # check if user belongs to WetlabManager . If true allow to see the page
        if groups not in request.user.groups.all():
            return render (request,'iSkyLIMS_wetlab/error_page.html', {'content':['You do have the enough privileges to see this page ','Contact with your administrator .']})
        if request.method == 'POST' and request.POST['action'] == 'change_run_name':
            new_run_name = request.POST['runName']
            if new_run_name == '':
                return render (request,'iSkyLIMS_wetlab/error_page.html', {'content':['Empty value is not allowed for the Run Name ']})
            if RunProcess.objects.filter(runName__exact = new_run_name).exists():
                return render (request,'iSkyLIMS_wetlab/error_page.html', {'content':['The given Run Name is already in use', 'Go back to the previous page and change the run name']})
            changed_run_name ={}
            old_run_name = run.runName
            run.runName = new_run_name
            run.save()
            changed_run_name ['new_run_name'] = [[new_run_name, run_id]]
            changed_run_name ['old_run_name'] = old_run_name

            return render (request, 'iSkyLIMS_wetlab/ChangeRunName.html', {'changed_run_name': changed_run_name})
        else:
            form_change_run_name ={}
            form_change_run_name['run_name'] = run.runName
            return render (request, 'iSkyLIMS_wetlab/ChangeRunName.html', {'form_change_run_name':form_change_run_name})
    else:
        return render (request,'iSkyLIMS_wetlab/error_page.html', {'content':['There is no Run for your query  ' ]})

@login_required
def change_project_libKit (request, project_id) :
    # check if project exists
    if Projects.objects.filter(pk = project_id).exists():
        project = Projects.objects.get(pk = project_id)
        if not request.user.is_authenticated:
            #redirect to login webpage
            return redirect ('/accounts/login')
        # check that user is allow to make the change
        allowed_access = check_user_access (request, project)
        if not allowed_access :
            return render (request,'iSkyLIMS_wetlab/error_page.html', {'content':['You do have the enough privileges to see this page ','Contact with your administrator .']})


        if request.method == 'POST' and request.POST['action'] == 'change_project_libKit':
            new_library_name = request.POST['projectlibkit']
            old_library_name = project.get_library_name()
            if old_library_name == new_library_name :
                return render (request, 'iSkyLIMS_wetlab/info_page.html', {'content': ['The library kit from the input text is the same to the existing defined for this project', 'No change is done']})
            # check if there is no other project in the same Run with the same Library Kit
            # if the library is shared with other project then error message is displayed

            if not check_user_group (request, 'WetlabManager') :
                project_run_id = project.runprocess_id.id
                project_lib_kit = project.libraryKit
                if Projects.objects.filter(runprocess_id = project_run_id).exclude(pk = project_id).exists():
                    all_project_with_same_run_id = Projects.objects.filter(runprocess_id = project_run_id).exclude(pk = project_id)
                    # there are more than 1 project on the same Run.
                    # check if these projects have in common the same library kit
                    other_lib_kits = []
                    for other_project in all_project_with_same_run_id:
                        other_lib_kits.append(other_project.libraryKit)
                    if  project_lib_kit in other_lib_kits:
                        message = str('The library Kit ' + old_library_name + 'is shared with other projects in the same Run ')

                        return render (request,'iSkyLIMS_wetlab/error_page.html', {'content':[message, '', 'Contact with your administrator .']})
            old_lib_kit_file = project.baseSpaceFile
            new_file_name = new_library_name.replace(' ' , '_')
            #
            new_file = update_library_kit_field(old_lib_kit_file,new_file_name,new_library_name)
            if new_file == 'ERROR':
                return render (request, 'iSkyLIMS_wetlab/error_page.html', {'content':['']})
            # update the database with new file
            project.baseSpaceFile = new_file
            project.libraryKit = new_library_name
            project.save()
            # Preparing the data to show in the web page
            new_file = project.baseSpaceFile
            change_library_kit_dict ={}
            change_library_kit_dict['project']= project.projectName
            change_library_kit_dict['library_name'] = new_library_name
            change_library_kit_dict['file_to_download'] = new_file

            #
            return render (request, 'iSkyLIMS_wetlab/ChangeProjectLibraryKit.html',{'changed_lib_kit':change_library_kit_dict})
        else:
            form_change_lib_kit ={}
            project_data =[]
            project_name = project.projectName
            form_change_lib_kit['project_name'] = project_name

            project_info_text = ['Run Name', 'Project Name', 'Project date', 'User Name', 'Library Kit']
            project_values = project.get_p_info_change_library().split(';')

            for item in range (len(project_info_text)):
                project_data.append([project_info_text[item], project_values[item]])
                form_change_lib_kit['project_data'] = project_data
            return render (request, 'iSkyLIMS_wetlab/ChangeProjectLibraryKit.html',{'form_change_lib_kit': form_change_lib_kit})
    else:
        return render (request,'iSkyLIMS_wetlab/error_page.html', {'content':['No project has been found for changing the library Kit ' ]})


@login_required
def change_run_libKit (request, run_id):
    #check if run exist
    if RunProcess.objects.filter(pk = run_id).exists():
        run = RunProcess.objects.get(pk = run_id)
        if not request.user.is_authenticated :
            return redirect ('/accounts/login')
        # check if user is allow to make the change
        groups = Group.objects.get(name='WetlabManager')
        # check if user belongs to WetlabManager . If true allow to see the page
        if groups not in request.user.groups.all():
            return render (request,'iSkyLIMS_wetlab/error_page.html', {'content':['You do have the enough privileges to see this page ','Contact with your administrator .']})
        if request.method == 'POST' and request.POST['action'] == 'change_run_libKit':
            new_library_kit = request.POST.getlist('runlibraryKit')
            projects_name = request.POST.getlist('projectInRun')
            changed_lib_kit_dict = {}

            # check if there is only one library kit associated to the run
            if len(new_library_kit) == 1 :
                # Check if new library kit was set in the form
                project = Projects.objects.get(projectName__exact = projects_name[0])
                old_library_kit = project.get_library_name()
                if new_library_kit[0] == old_library_kit :
                    return render (request, 'iSkyLIMS_wetlab/info_page.html', {'content': ['The library kit from the input text is the same to the existing defined for this project', 'No change is done']})
                # change the library name
                old_lib_kit_file = project.baseSpaceFile
                new_file_name = new_library_kit[0].replace(' ' , '_')
                #

                new_file = update_library_kit_field(old_lib_kit_file,new_file_name,new_library_kit[0])
                if new_file == 'ERROR':
                    return render (request, 'iSkyLIMS_wetlab/error_page.html', {'content':['']})
                # update the database with new file
                project.baseSpaceFile = new_file
                project.libraryKit = new_library_kit[0]
                project.save()

            else:
                old_files_to_be_deleted = []
                # check if any of the library has change
                need_to_be_updated = False
                for item in range(len(projects_name)):
                    project = Projects.objects.get(projectName__exact = projects_name[item])
                    old_library_kit = project.libraryKit
                    # get the library kit file name to delete it later
                    old_file = project.baseSpaceFile
                    # build the list to delete later the old library kit files
                    if old_file not in old_files_to_be_deleted :
                        old_files_to_be_deleted.append(old_file)
                    if new_library_kit[item] != old_library_kit:
                        need_to_be_updated = True
                if not need_to_be_updated:
                    return render (request, 'iSkyLIMS_wetlab/info_page.html', {'content': ['The library kits from the input text are the same to the existing ones defined for the Run', 'No change is done']})
                # get the Sample Sheet file related to the run
                sample_file = run.get_sample_file()

                lib_kit_dict = {}
                in_file=str('documents/' + sample_file)
                #
                ## build the project list for each library kit
                for x in range(len(new_library_kit)):
                    if new_library_kit[x] in lib_kit_dict :
                        lib_kit_dict[new_library_kit[x]].append(projects_name[x])
                    else:
                        lib_kit_dict[new_library_kit[x]]= [projects_name[x]]

                ## convert the sample sheet to base space format and have different files according the library kit
                #

                for key, value in lib_kit_dict.items():
                    lib_kit_file =key.replace(' ', '_')
                    library_file = sample_sheet_map_basespace(in_file, key, lib_kit_file, value,'Plate96')
                    if library_file == 'ERROR':
                        return render (request,'iSkyLIMS_wetlab/error_page.html', {'content':[ 'The information on  the Library kit ', key,' For the project ', value,
                          'could not be changed to the new value of the library kit ','ADVICE', 'Contact your administrator']})
                    for updated_project_name in value :
                        p_updated = Projects.objects.get(projectName__exact = updated_project_name)
                        p_updated.libraryKit = key
                        p_updated.baseSpaceFile = library_file
                        p_updated.save()
                # delete old library kit files
                for delete_file in old_files_to_be_deleted :
                    os.remove(delete_file)
                # prepare the information to be displayed
            changed_lib_kit_dict = {}
            run_data = {}
            for item in range(len(projects_name)) :
                project = Projects.objects.get(projectName__exact = projects_name[item])
                p_name =project.projectName
                lib_name = project.libraryKit
                lib_file = project.baseSpaceFile
                run_data[p_name] = ([[lib_name, lib_file]])

            changed_lib_kit_dict['run_name'] = run.get_run_name()
            changed_lib_kit_dict['run_data'] = run_data

            return render (request, 'iSkyLIMS_wetlab/ChangeRunLibraryKit.html',{'changed_lib_kit': changed_lib_kit_dict})

        else:
            form_change_lib_kit = {}
            run_library_data = []
            project_list = []
            #library_kit_list = []
            library_kit_dict = {}
            form_change_lib_kit['run_name'] = run.get_run_name()
            # get the projects and the library Kits used in each project
            project_list = Projects.objects.filter(runprocess_id = run_id)
            for project in project_list :
                lib_kit = project.libraryKit
                run_library_data.append([project.projectName, lib_kit])
                if lib_kit in library_kit_dict :
                    library_kit_dict[project.libraryKit].append(project.projectName)
                else :
                    library_kit_dict[project.libraryKit] = [project.projectName]

            form_change_lib_kit['run_data'] = library_kit_dict
            form_change_lib_kit['run_library_data'] = run_library_data

            return render (request, 'iSkyLIMS_wetlab/ChangeRunLibraryKit.html',{'form_change_lib_kit': form_change_lib_kit})
    else:
        return render (request,'iSkyLIMS_wetlab/error_page.html', {'content':['No run has been found for changing the library Kit ' ]})

@login_required
def stats_experiment (request):
    return render (request, 'iSkyLIMS_wetlab/StatsPerExperiment.html', {})

@login_required
def stats_per_researcher (request):
    if request.method == 'POST':
        r_name = request.POST['researchername']
        start_date=request.POST['startdate']
        end_date=request.POST['enddate']

        if start_date != '':
            try:
                datetime.datetime.strptime(start_date, '%Y-%m-%d')
            except:
                return render (request,'iSkyLIMS_wetlab/error_page.html', {'content':['The format for the "From Start Date" Field is incorrect ',
                                                                    'ADVICE:', 'Use the format  (YYYY-MM-DD)']})
        if end_date !='' :
            try:
                datetime.datetime.strptime(end_date, '%Y-%m-%d')
            except:
                return render (request,'iSkyLIMS_wetlab/error_page.html', {'content':['The format for the "End Date Search" Field is incorrect ',
                                                                    'ADVICE:', 'Use the format  (YYYY-MM-DD)']})
        if len(r_name) < 5 :
            return render (request,'iSkyLIMS_wetlab/error_page.html', {'content':['researcher name is too sort fo fined a match', 'Name must be at least 6 characters long'
                                                            'ADVICE:', 'write a longer name in the researcher field ']})

        if User.objects.filter(username__icontains = r_name).exists():
            r_name = User.objects.get(username__icontains = r_name).username
            r_name_id = User.objects.get(username__icontains = r_name).id
            if Projects.objects.filter(user_id__exact =r_name_id).exists():
                if Projects.objects.filter(user_id__exact =r_name_id, runprocess_id__state__runStateName = "Completed").exists():
                    r_project_by_researcher = Projects.objects.filter(user_id__exact =r_name_id, runprocess_id__state__runStateName = "Completed").order_by('project_run_date')

                # check if start and end date are present in the form
                    if start_date != '' and end_date !='':
                        if Projects.objects.filter(user_id__exact =r_name_id, runprocess_id__state__runStateName = "Completed", project_run_date__range=(start_date, end_date)).exists():
                            r_project_by_researcher = Projects.objects.filter(user_id__exact =r_name_id, runprocess_id__state__runStateName = "Completed", project_run_date__range=(start_date, end_date))
                            #r_project_by_researcher = r_project_by_researcher.filter(generatedat__range=(start_date, end_date))
                        else:
                            return render (request,'iSkyLIMS_wetlab/error_page.html', {'content':['Researcher does not have projects associated for the period ',
                                                    'starting date  = ', start_date, 'and with ending date = ', end_date,
                                                                'ADVICE:', 'Contact with your administrator']})
                    if start_date != '' and end_date =='':
                        end_date = str(datetime.datetime.now().date())
                        if Projects.objects.filter(user_id__exact =r_name_id, runprocess_id__state__runStateName = "Completed",project_run_date__range=(start_date, end_date)).exists():
                            r_project_by_researcher = Projects.objects.filter(user_id__exact =r_name_id,runprocess_id__state__runStateName = "Completed", project_run_date__range=(start_date, end_date))
                        else:
                            return render (request,'iSkyLIMS_wetlab/error_page.html', {'content':['Researcher does not have projects associated for the period ',
                                                    'starting date  = ', start_date,
                                                                'ADVICE:', 'Contact with your administrator']})
                    if start_date == '' and end_date !='':
                        if Projects.objects.filter(user_id__exact =r_name_id, runprocess_id__state__runStateName = "Completed", project_run_date__lte= end_date).exists():
                            r_project_by_researcher = Projects.objects.filter(user_id__exact =r_name_id, runprocess_id__state__runStateName = "Completed", project_run_date__lte = end_date)
                        else:
                            return render (request,'iSkyLIMS_wetlab/error_page.html', {'content':['Researcher does not have projects associated for the period ',
                                                    'ending date  = ', end_date,
                                                                'ADVICE:', 'Contact with your administrator']})

                    researcher_statistics = {}

                    # Get data from researcher projects

                    researcher_statistics ['projects_heading'] = ['Project name', 'Date', 'Libraty Kit','Samples', 'Cluster PF', 'Yield Mb', '% Q> 30', 'Mean','Sequencer ID']
                    projects_data =[]
                    p_researcher_date , p_researcher_num_sample = {} , {}
                    p_researcher_lib_kit, p_researcher_sequencer = {}, {}
                    p_researcher_q30_dict, p_researcher_mean_dict = {} , {}
                    p_researcher_yield_mb_dict, p_researcher_cluster_pf_dict ={} , {}
                    projects_name_dict , projects_id_list = {} , {}


                    for project_researcher in r_project_by_researcher:
                        q_30_list , mean_q_list = [] , []
                        yield_mb_list,  cluster_pf_list = [], []
                        p_name = project_researcher.get_project_name()

                        sequencer_in_project = project_researcher.runprocess_id.get_run_sequencerModel()
                        if not sequencer_in_project in projects_name_dict :
                            p_researcher_num_sample[sequencer_in_project] ={}
                            p_researcher_sequencer[sequencer_in_project] ={}
                            p_researcher_date[sequencer_in_project] ={}
                            p_researcher_lib_kit[sequencer_in_project] ={}
                            p_researcher_q30_dict[sequencer_in_project] ={}
                            p_researcher_mean_dict[sequencer_in_project] ={}
                            p_researcher_yield_mb_dict[sequencer_in_project] ={}
                            p_researcher_cluster_pf_dict[sequencer_in_project] ={}
                            projects_name_dict[sequencer_in_project] = []
                            projects_id_list[sequencer_in_project] =  []
                        projects_name_dict[sequencer_in_project].append(p_name)
                        r_project_id = project_researcher.id
                        projects_id_list[sequencer_in_project].append(r_project_id)
                        p_researcher_num_sample[sequencer_in_project][p_name] = StatsFlSummary.objects.get(project_id__exact = r_project_id).sampleNumber
                        p_researcher_date [sequencer_in_project][p_name] = project_researcher.get_date()
                        p_researcher_lib_kit[sequencer_in_project][p_name]= project_researcher.get_library_name()
                        #
                        p_researcher_sequencer[sequencer_in_project][p_name] = str(project_researcher.runprocess_id.sequencerModel)
                        lanes_in_project = StatsLaneSummary.objects.filter( project_id__exact = r_project_id)
                        for lane in lanes_in_project :
                            q_30_value, mean_q_value , yield_mb_value , cluster_pf_value = lane.get_stats_info().split(';')
                            q_30_list.append(float(q_30_value))
                            mean_q_list.append(float(mean_q_value))
                            yield_mb_list.append(float(yield_mb_value.replace(',','')))
                            cluster_pf_list.append(float(cluster_pf_value.replace(',','')))
                        p_researcher_q30_dict[sequencer_in_project] [p_name]= format(statistics.mean(q_30_list), '.2f')
                        p_researcher_mean_dict[sequencer_in_project][p_name] = format(statistics.mean(mean_q_list), '.2f')
                        p_researcher_yield_mb_dict[sequencer_in_project][p_name] = round(sum(yield_mb_list))
                        p_researcher_cluster_pf_dict[sequencer_in_project][p_name] = round(sum(cluster_pf_list))

                    # Create the table with projects executed by the researcher
                    researcher_seq_graphs, researcher_graphs = [], []
                    for sequencer, projects_name_list in projects_name_dict.items() :
                        sequencer_proj = {}
                        proj_data =[]
                        for project_name in projects_name_list :
                            proj_data.append([project_name, p_researcher_date[sequencer][project_name], p_researcher_lib_kit[sequencer][project_name],
                                    p_researcher_num_sample[sequencer][project_name], '{0:,}'.format(int(p_researcher_cluster_pf_dict[sequencer][project_name])),
                                    '{0:,}'.format(int(p_researcher_yield_mb_dict[sequencer][project_name])), p_researcher_q30_dict[sequencer][project_name],
                                    p_researcher_mean_dict[sequencer][project_name], p_researcher_sequencer[sequencer][project_name]])
                        sequencer_proj[sequencer] = proj_data
                        projects_data.append(sequencer_proj)
                        # create the graphic for q30 quality
                        theme = 'ocean'
                        heading = 'Graphics for Q > 30 for investigator ' + r_name
                        sub_caption = 'Sequencer ' + sequencer
                        x_axis_name = 'Projects'
                        y_axis_name = 'Q 30 (in %)'

                        data_source = column_graphic_simple (heading, sub_caption, x_axis_name, y_axis_name, theme, p_researcher_q30_dict[sequencer])
                        seq_chart = sequencer + 'q30_chart'
                        seq_graph = sequencer + 'q30_graph'
                        q30_researcher_seq_graph = FusionCharts("column3d", seq_graph , "500", "350",seq_chart , "json", data_source).render()

                        researcher_seq_graphs.append([seq_chart, q30_researcher_seq_graph])
                        # create the graphic for mean quality
                        theme = 'carbon'
                        heading = 'Graphics for Mean quality for investigator ' + r_name
                        sub_caption = 'Sequencer ' + sequencer
                        x_axis_name = 'Projects'
                        y_axis_name = 'Mean Quality'
                        data_source = column_graphic_simple (heading, sub_caption, x_axis_name, y_axis_name, theme, p_researcher_mean_dict[sequencer])
                        seq_chart = sequencer + 'mean_q_chart'
                        seq_graph = sequencer + 'mean_q_graph'
                        mean_q_researcher_seq_graph = FusionCharts("column3d", seq_graph , "500", "350", seq_chart, "json", data_source).render()
                        researcher_seq_graphs.append([seq_chart, mean_q_researcher_seq_graph])

                        # create the graphic for yield Mb
                        theme = 'zune'
                        heading = 'Graphics for Yield Mb for investigator ' + r_name
                        sub_caption = 'Sequencer ' + sequencer
                        x_axis_name = 'Projects'
                        y_axis_name = 'Yield Mb'
                        data_source = column_graphic_simple (heading, sub_caption, x_axis_name, y_axis_name, theme, p_researcher_yield_mb_dict[sequencer])
                        seq_chart = sequencer + 'yield_mb_chart'
                        seq_graph = sequencer + 'yield_mb_graph'
                        yield_mb_researcher_graph = FusionCharts("column3d", seq_graph , "500", "350", seq_chart, "json", data_source).render()
                        researcher_seq_graphs.append([seq_chart, yield_mb_researcher_graph])
                        # create the graphic for cluster Pf
                        theme = 'ocean'
                        heading = 'Graphics for Cluster Pf for investigator ' + r_name
                        sub_caption = 'Sequencer ' + sequencer
                        x_axis_name = 'Projects'
                        y_axis_name = 'Cluster Pf'
                        data_source = column_graphic_simple (heading, sub_caption, x_axis_name, y_axis_name, theme, p_researcher_cluster_pf_dict[sequencer])
                        seq_chart = sequencer + 'cluster_pf_chart'
                        seq_graph = sequencer + 'cluster_pf_graph'
                        cluster_pf_researcher_graph = FusionCharts("column3d", seq_graph , "500", "350", seq_chart, "json", data_source).render()
                        researcher_seq_graphs.append([seq_chart, cluster_pf_researcher_graph])


                        researcher_graphs.append(researcher_seq_graphs)

                    researcher_statistics ['researcher_graph'] = researcher_graphs
                    researcher_statistics ['researcher_name'] = r_name
                    researcher_statistics['projects_data'] = projects_data


                    #collecting data for comparation graphics

                    # Calculating the mean for all projects performed by researcher
                    comp_q30_dict, comp_mean_q_dict = {} , {}
                    comp_yield_mb_dict, comp_cluster_pf_dict = {} , {}

                    q30_val = p_researcher_q30_dict.values()
                    mean_q_val = p_researcher_mean_dict.values()
                    yield_mb_val = p_researcher_yield_mb_dict.values()
                    cluster_pf = p_researcher_cluster_pf_dict.values()

                    for sequencer in projects_name_dict.keys() :
                        #sequencer_proj = {}
                        #proj_data =[]
                        comp_q30_dict[sequencer] , comp_mean_q_dict [sequencer]= {} , {}
                        comp_yield_mb_dict[sequencer], comp_cluster_pf_dict [sequencer] = {}, {}
                        comp_q30_dict [sequencer][r_name] = format(statistics.mean( [float(x) for x in list(p_researcher_q30_dict[sequencer].values())]),'.2f')
                        comp_mean_q_dict[sequencer] [r_name] = format(statistics.mean( [float(x) for x in list(p_researcher_mean_dict[sequencer].values())]),'.2f')

                        comp_yield_mb_dict[sequencer] [r_name] = sum(list(p_researcher_yield_mb_dict[sequencer].values()))
                        comp_cluster_pf_dict[sequencer] [r_name] = sum(list(p_researcher_cluster_pf_dict[sequencer].values()))

                    total_q_30_list, total_mean_q_list = [] , []
                    total_yield_mb_list, total_cluster_pf_list = [] , []
                    total_lanes_summary = {}

                    for sequencer in projects_name_dict.keys() :
                        runs_sequencer = RunProcess.objects.filter(sequencerModel__machineName__exact = sequencer)
                        run_sequencer_id_list = []
                        for run in runs_sequencer :
                            run_sequencer_id_list.append(run.pk)

                        if StatsLaneSummary.objects.filter(runprocess_id__in  = run_sequencer_id_list).exclude(defaultAll__isnull = False).exclude(project_id__in = projects_id_list[sequencer]).exists():
                            total_lanes_summary[sequencer] = StatsLaneSummary.objects.filter(runprocess_id__in  = run_sequencer_id_list).exclude(defaultAll__isnull = False).exclude(project_id__in = projects_id_list[sequencer])
                        else:
                            total_lanes_summary[sequencer] = ''


                    comp_graphs, comp_seq_graphs = [] , []
                    for sequencer in projects_name_dict.keys() :
                        for lane_summary in total_lanes_summary[sequencer] :
                            q_30_value, mean_q_value , yield_mb_value , cluster_pf_value = lane_summary.get_stats_info().split(';')
                            total_q_30_list.append(float(q_30_value))
                            total_mean_q_list.append(float(mean_q_value))
                            total_yield_mb_list.append(int(yield_mb_value.replace(',','')))
                            total_cluster_pf_list.append(int(cluster_pf_value.replace(',','')))
                        comp_q30_dict[sequencer]['Other investigators']= format(statistics.mean(total_q_30_list), '.2f')
                        comp_mean_q_dict[sequencer]['Other investigators'] = format(statistics.mean(total_mean_q_list), '.2f')
                        comp_yield_mb_dict[sequencer]['Other investigators'] = sum(total_yield_mb_list)
                        comp_cluster_pf_dict[sequencer]['Other investigators'] = sum(total_cluster_pf_list)
                        # create the graphic for q30 quality

                        theme = ''
                        heading = 'Comparation graphics for Q > 30 for investigator ' + r_name
                        sub_caption = ''
                        x_axis_name = r_name + ' versus other investigators'
                        y_axis_name = 'Q 30 (in %)'

                        data_source = column_graphic_simple (heading, sub_caption, x_axis_name, y_axis_name, theme, comp_q30_dict[sequencer])
                        seq_chart = sequencer + 'comparation_q30_chart'
                        seq_graph = sequencer + 'comparation_q30_graph'
                        comp_q30_seq_graph = FusionCharts("column3d", seq_graph , "500", "350",seq_chart , "json", data_source).render()
                        comp_seq_graphs.append([seq_chart, comp_q30_seq_graph])

                        theme = ''
                        heading = 'Comparation graphics for Mean Quality for investigator ' + r_name
                        sub_caption = ''
                        x_axis_name = r_name + ' versus other investigators'
                        y_axis_name = 'Mean Quality'
                        data_source = column_graphic_simple (heading, sub_caption, x_axis_name, y_axis_name, theme, comp_mean_q_dict[sequencer])
                        seq_chart = sequencer + 'comparation_mean_q_chart'
                        seq_graph = sequencer + 'comparation_mean_q_graph'
                        comp_mean_q_seq_graph = FusionCharts("column3d", seq_graph , "500", "350",seq_chart , "json", data_source).render()
                        comp_seq_graphs.append([seq_chart, comp_mean_q_seq_graph])

                        theme = ''
                        heading = 'Comparation graphics for Yield (Mb) for investigator ' + r_name
                        sub_caption = ''
                        x_axis_name = r_name + ' versus other investigators'
                        y_axis_name = '(Mb)'
                        data_source = column_graphic_simple (heading, sub_caption, x_axis_name, y_axis_name, theme, comp_yield_mb_dict[sequencer])
                        seq_chart = sequencer + 'comparation_yield_mb_chart'
                        seq_graph = sequencer + 'comparation_yield_mb_graph'
                        comp_yield_mb_seq_graph = FusionCharts("column3d", seq_graph , "500", "350",seq_chart , "json", data_source).render()
                        comp_seq_graphs.append([seq_chart, comp_yield_mb_seq_graph])

                        theme = ''
                        heading = 'Comparation graphics for Cluster PF for investigator ' + r_name
                        sub_caption = ''
                        x_axis_name = r_name + ' versus other investigators'
                        y_axis_name = 'Cluster pf'
                        data_source = column_graphic_simple (heading, sub_caption, x_axis_name, y_axis_name, theme, comp_cluster_pf_dict[sequencer])
                        seq_chart = sequencer + 'comparation_cluster_pf_chart'
                        seq_graph = sequencer + 'comparation_cluster_pf_graph'
                        comp_cluster_pf_seq_graph = FusionCharts("column3d", seq_graph , "500", "350",seq_chart , "json", data_source).render()
                        comp_seq_graphs.append([seq_chart, comp_cluster_pf_seq_graph])
                        comp_graphs.append(comp_seq_graphs)

                    researcher_statistics ['comp_graphs'] = comp_graphs

                    # Sequencer graphic utilization
                    sequencer_used = {}
                    for sequencer in projects_name_dict.keys() :
                        sequencer_used[sequencer] = len( projects_name_dict[sequencer])

                    theme = 'ocean'
                    heading = 'Sequencer utilization for investigator ' + r_name
                    sub_caption = ''
                    data_source = pie_graphic_standard (heading, sub_caption, theme, sequencer_used)
                    sequencer_pie_graph = FusionCharts("pie3d", "sequencer_pie_graph" , "500", "400", "sequencer_pie_chart", "json", data_source).render()
                    researcher_statistics ['sequencer_pie_graph'] = sequencer_pie_graph

                    return  render(request, 'iSkyLIMS_wetlab/StatsPerResearcher.html', {'researcher_statistics' : researcher_statistics})
                else:
                    return render (request,'iSkyLIMS_wetlab/error_page.html', {'content':['Researcher does not have projects in Completed state. ',
                                                            'ADVICE:', 'Contact with your administrator']})
            else:
                return render (request,'iSkyLIMS_wetlab/error_page.html', {'content':['Researcher does not have projects associated to him ',
                                                            'ADVICE:', 'Contact with your administrator']})
        else:
            return render (request,'iSkyLIMS_wetlab/error_page.html', {'content':['No matches have been found for researcher name  ',
                                                                'ADVICE:', 'Contact with your administrator']})
    else:
        return render (request, 'iSkyLIMS_wetlab/StatsPerResearcher.html', {})


@login_required
def stats_per_time (request):
    if request.method=='POST':
        start_date=request.POST['startdate']
        end_date=request.POST['enddate']
         ### check the right format of start and end date
        if start_date != '':
            try:
                datetime.datetime.strptime(start_date, '%Y-%m-%d')
            except:
                return render (request,'iSkyLIMS_wetlab/error_page.html', {'content':['The format for the "Start Date Search" Field is incorrect ',
                                                                    'ADVICE:', 'Use the format  (YYYY-MM-DD)']})
        if end_date != '':
            try:
                datetime.datetime.strptime(end_date, '%Y-%m-%d')
            except:
                return render (request,'iSkyLIMS_wetlab/error_page.html', {'content':['The format for the "End Date Search" Field is incorrect ',
                                                                    'ADVICE:', 'Use the format  (YYYY-MM-DD)']})

        #############################################################
        #### searching for runs were match the state and start and end date
        #############################################################
        if (start_date != '' and end_date != ''):
            stat_per_time ={}
            if (RunProcess.objects.filter( state__runStateName='Completed', run_date__range=(start_date, end_date)).exists()):
                run_stats_list=RunProcess.objects.filter(state__runStateName='Completed', run_date__range=(start_date, end_date)).order_by('run_date')
                #

                run_list={}
                run_date_name ={}
                ## get the run names that matches de conditions
                for run in run_stats_list:
                    #run_list.append([run.get_run_name(),run.id])
                    run_date = str(run.run_date)
                    if run_date in run_date_name:
                        run_date_name [run_date] +=1
                    else:
                        run_date_name[run_date] = 1
                    run_list [run.id] = [[run.get_run_name(), run_date]]
                    #
                stat_per_time ['run_names'] = run_list
                if len (run_stats_list) == 1:
                    number_of_runs = '1 Run'
                else:
                    number_of_runs = str(len (run_stats_list)) + '  Runs'
                stat_per_time ['number_of_runs'] = number_of_runs
                stat_per_time ['dates'] = start_date + ' and  ' + end_date
                #
                ############################################################
                ### define the graphics for found run in the period
                heading = 'Runs found during the period ' + str(start_date) + ' and ' + str(end_date)
                sub_caption = ''
                x_axis_name = 'Date'
                y_axis_name = 'Number of runs'
                run_period_chart_number = 'run_period_chart-1'
                run_period_index_graph = 'exq1'

                data_source = researcher_project_column_graphic (heading, sub_caption, x_axis_name, y_axis_name, 'ocean', run_date_name)
                stat_per_time['run_period_graphic'] = FusionCharts("column3d", run_period_index_graph , "550", "350", run_period_chart_number, "json", data_source).render()

                ####### end creation run preparation graphics

                #############################################################
                ### collect statistics for Projects
                if (Projects.objects.filter(runprocess_id__state__runStateName__exact = 'Completed', project_run_date__range=(start_date, end_date)).exists()):
                    project_found_list = Projects.objects.filter( runprocess_id__state__runStateName = 'Completed', project_run_date__range=(start_date, end_date))

                    project_list={}
                    project_date_name ={}
                    ## get the project names that matches de conditions
                    for project in project_found_list:
                        project_run_date = str(project.project_run_date)
                        if project_run_date in project_date_name:
                            project_date_name [project_run_date] +=1
                        else:
                            project_date_name[project_run_date] = 1
                        project_list [project.id] = [[project.get_project_name(), project_run_date]]
                        #
                    stat_per_time ['project_names'] = project_list
                    if len (project_found_list) == 1:
                        number_of_projects = '1 Project'
                    else:
                        number_of_projects = str(len (project_found_list)) + '  Projects'
                    stat_per_time ['number_of_projects'] = number_of_projects
                    stat_per_time ['dates'] = start_date + ' and  ' + end_date
                    #
                    ############################################################
                    ### define the graphics for found run in the period
                    heading = 'Projects found during the period ' + str(start_date) + ' and ' + str(end_date)
                    sub_caption = ''
                    x_axis_name = 'Date'
                    y_axis_name = 'Number of Projects'
                    run_period_chart_number = 'project_period_chart-1'
                    run_period_index_graph = 'project_period-1'

                    data_source = researcher_project_column_graphic (heading, sub_caption, x_axis_name, y_axis_name, 'carbon', project_date_name)
                    stat_per_time['project_period_graphic'] = FusionCharts("column3d", run_period_index_graph , "550", "350", run_period_chart_number, "json", data_source).render()

                ####### end creation run preparation graphics
                #############################################################
                ### collect statistics for unkow Barcodes
                #top_unbarcode_list = []
                count_unbarcode  = {}

                for run in run_stats_list:
                    run_id = run.id
                    number_of_lanes=run.get_machine_lanes()
                    top_unbarcode_all_runs  = {}
                    for lane_number in range (1, number_of_lanes +1):
                        lane_unbarcodes = RawTopUnknowBarcodes.objects.filter(runprocess_id =run, lane_number__exact = lane_number)
                        for lane_unbarcode in lane_unbarcodes :
                            if not lane_number in count_unbarcode :
                                count_unbarcode[lane_number] = {}
                            unbarcode_num , unknown_barcode,  = lane_unbarcode.get_unknow_barcodes().split(';')
                            value_unbarcode = int(unbarcode_num.replace(',',''))
                            if not unknown_barcode in count_unbarcode[lane_number] :
                                count_unbarcode[lane_number][unknown_barcode] = value_unbarcode
                            else:
                                count_unbarcode[lane_number][unknown_barcode] += value_unbarcode
                            if not unknown_barcode in top_unbarcode_all_runs :
                                top_unbarcode_all_runs[unknown_barcode] = value_unbarcode
                            else:
                                top_unbarcode_all_runs[unknown_barcode] += value_unbarcode

                themes = ['','ocean','fint','carbon','zune', '']
                # prepare the column graphic for nunber of top Unknow Barcode
                unbar_lane_chart = []
                for lane_number in range (1, number_of_lanes +1):
                    heading = 'Number of undetermined barcode sequence in lane ' + str(lane_number)
                    chart_number = 'chart-' + str(lane_number)
                    render_number = 'ex'+ str(lane_number)
                    lane_chart = 'lane_chart'+ str(lane_number)
                    data_source = graphic_for_unbarcodes(heading , themes[lane_number] , count_unbarcode[lane_number])
                    lane_graphic = FusionCharts("column3d", render_number , "500", "400", chart_number, "json", data_source)
                    unbar_lane_chart.append([chart_number, str(lane_number),lane_graphic.render()])
                stat_per_time ['unbar_lane_chart'] = unbar_lane_chart


                # prepare the pie graphic for the number of top Unknow Barcode per sequence
                data_source = pie_graphic ('Number of count for the Undetermined Sequences', 'fint',top_unbarcode_all_runs)
                unknow_pie3d = FusionCharts("pie3d", "ex5" , "500", "400", "chart-5", "json", data_source)
                stat_per_time ['unknow_pie3d'] = unknow_pie3d.render()

                #########################
                ### Insert information for disk space utilization
                run_disk_utilization ={}
                for run_disk_stats in run_stats_list :
                    run_name_disk = run_disk_stats.runName
                    run_disk_utilization[run_name_disk] = run_disk_stats.get_disk_space_utilization()


                heading = 'Disk space used for each Run found during the period ' + str(start_date) + ' and ' + str(end_date)
                sub_caption = ''
                x_axis_name = 'Date'
                y_axis_name = 'Disk space used (MB)'
                disk_space_period_chart_number = 'disk_usage_chart-1'
                disk_space_period_index_graph = 'diskusage1'

                data_source = researcher_project_column_graphic (heading, sub_caption, x_axis_name, y_axis_name, 'carbon', run_disk_utilization)
                stat_per_time['disk_space_period_graphic'] = FusionCharts("column3d", disk_space_period_index_graph , "550", "350", disk_space_period_chart_number, "json", data_source).render()

                #
                return render(request, 'iSkyLIMS_wetlab/StatsPerTime.html', {'display_stats_per_time': stat_per_time })

            else:
                return render (request,'iSkyLIMS_wetlab/error_page.html', {'content':['No matches have been found for Runs created between', start_date, ' and the ',  end_date ]})
        else:
            return render (request,'iSkyLIMS_wetlab/error_page.html', {'content':'Start date and End Date cannot be empty '})

        #############################################################

    return render (request,'iSkyLIMS_wetlab/StatsPerTime.html')

def get_list_of_libraries_values (library_found, q30_comparations, mean_comparations , n_bases_comparations) :

    for project_to_compare in library_found :
        library_to_compare_name = project_to_compare.get_library_name()
        project_to_compare_id = project_to_compare.id
        q30_compare_lib, mean_compare_lib, yield_mb_compare_lib = [], [] , []
        # get the number of lanes by quering the SequencerModel in the RunProcess
        number_of_lanes = project_to_compare.runprocess_id.get_machine_lanes()
        for lane_number in range (1,number_of_lanes + 1):
            lane_in_project = StatsLaneSummary.objects.get(project_id__exact = project_to_compare_id, lane__exact = lane_number)
            q_30_value, mean_q_value, yield_mb , cluster_pf = lane_in_project.get_stats_info().split(';')
            q30_compare_lib.append(float(q_30_value))
            mean_compare_lib.append(float(mean_q_value))
            yield_mb_compare_lib.append(float(yield_mb.replace(',','')))
        if library_to_compare_name in q30_comparations:
            q30_tmp_list =[float(q30_comparations [library_to_compare_name]), statistics.mean (q30_compare_lib)]
            q30_comparations [library_to_compare_name] = format(statistics.mean (q30_tmp_list), '.2f')
            mean_tmp_list = [float(mean_comparations [library_to_compare_name]), statistics.mean (mean_compare_lib)]
            mean_comparations [library_to_compare_name] = format(statistics.mean (mean_tmp_list), '.2f')
            n_bases_list =[float(n_bases_comparations [library_to_compare_name]), sum (yield_mb_compare_lib)]

            n_bases_comparations [library_to_compare_name] = format(statistics.mean (n_bases_list), '.2f')
        else:
            q30_comparations [library_to_compare_name] = format(statistics.mean (q30_compare_lib), '.2f')
            mean_comparations [library_to_compare_name] = format(statistics.mean (mean_compare_lib), '.2f')
            n_bases_comparations [library_to_compare_name] = format(statistics.mean (yield_mb_compare_lib), '.2f')


@login_required
def stats_per_library (request):
    if request.method=='POST' :
        library_kit_name=request.POST['libraryKitName']
        start_date=request.POST['startdate']
        end_date=request.POST['enddate']
        # check that some values are in the request if not return the form
        if library_kit_name == '' and start_date == '' and end_date == '' :
            return render(request, 'iSkyLIMS_wetlab/StatsPerLibrary.html')

        if library_kit_name !=''  and len(library_kit_name) <3 :
             return render (request,'iSkyLIMS_wetlab/error_page.html', {'content':['The user name must contains at least 4 caracters ',
                                                                    'ADVICE:', 'write the full Library Kit name to get a better match']})
        ### check the right format of start and end date
        if start_date != '':
            try:
                datetime.datetime.strptime(start_date, '%Y-%m-%d')
            except:
                return render (request,'iSkyLIMS_wetlab/error_page.html', {'content':['The format for the "Start Date Search" Field is incorrect ',
                                                                    'ADVICE:', 'Use the format  (YYYY-MM-DD)']})
        if end_date != '':
            try:
                datetime.datetime.strptime(end_date, '%Y-%m-%d')
            except:
                return render (request,'iSkyLIMS_wetlab/error_page.html', {'content':['The format for the "End Date Search" Field is incorrect ',
                                                                    'ADVICE:', 'Use the format  (YYYY-MM-DD)']})
        if library_kit_name != '':
            if Projects.objects.filter(libraryKit__icontains = library_kit_name, runprocess_id__state__runStateName__exact = 'Completed').exists():
                library_found = Projects.objects.filter(libraryKit__icontains = library_kit_name, runprocess_id__state__runStateName__exact = 'Completed')
            else:
                return render (request,'iSkyLIMS_wetlab/error_page.html', {'content':['There are no Library containing ', library_kit_name]})
        else:
            library_found = Projects.objects.filter(runprocess_id__state__runStateName__exact = 'Completed')
        if (start_date != '' and end_date != ''):
            if library_found.filter(project_run_date__range=(start_date, end_date)).exists():
                 library_found = library_found.filter(project_run_date__range=(start_date, end_date))
            else:
                return render (request,'iSkyLIMS_wetlab/error_page.html', {'content':['There are no Library containing ', library_kit_name,
                                        ' created between ', start_date, 'and the ', end_date]})
        if start_date !='' and end_date == '':
            if library_found.filter(project_run_date__gte = start_date).exists():
                 library_found = library_found.filter(project_run_date__gte = start_date)
                 #
            else:
                return render (request,'iSkyLIMS_wetlab/error_page.html', {'content':['There are no Library containing ', library_kit_name,
                                        ' starting from', start_date]})
        if start_date =='' and end_date != '':
            if library_found.filter(project_run_date__lte = end_date).exists():
                #
                library_found = library_found.filter(project_run_date__lte = end_date)
            else:
                return render (request,'iSkyLIMS_wetlab/error_page.html', {'content':['There are no Library containing ', library_kit_name,
                                        ' finish before ', end_date]})

        #Collecting the statistics for the selected library
        # Get the projects which are using the library kit
        #
        library_stats ={}
        projects_name_in_library =[]
        q_30_list , mean_q_list , yield_mb_list = [] , [] ,[]
        # Getting 1 library. Library could be in several projects. Information is collected per lane and by project
        #check if only 1 library kit matches the query
        library_names ={}
        for library in library_found :
            library_names [library.libraryKit] = 1
        #
        if len(library_names) == 1:
            # There is only 1 library in the query. Results displays all projects data which have this library kit
            mean_lane_graphic ={}
            for project in library_found :
                projects_name_in_library.append(project.get_project_name())
            q30_in_lib, mean_in_lib, yield_mb_in_lib = [], [] , []
            for lane_number in range (1,5):
                q_30_lane , mean_q_lane , yield_mb_lane = {} , {} ,{}
                for project in library_found :
                    project_id = project.id
                    # Get quality information for each Lane summary of the project id
                    #
                    lane_in_project = StatsLaneSummary.objects.get(project_id__exact = project_id, lane__exact = lane_number)
                    q_30_value, mean_q_value, yield_mb , cluster_pf = lane_in_project.get_stats_info().split(';')
                    project_name = project.get_project_name()
                    q_30_lane[project_name] = q_30_value
                    q30_in_lib.append(float(q_30_value))
                    mean_q_lane[project_name] = mean_q_value
                    mean_in_lib.append(float(mean_q_value))
                    yield_mb_lane[project_name] = yield_mb.replace(',','')
                    yield_mb_in_lib.append(float(yield_mb.replace(',','')))
                    #
                # creating the Yield MBases graphics
                chart_number = 'chart-' + str(lane_number)
                render_number = 'ex'+ str(lane_number)
                heading = 'Number of MBases in the projects for Lane ' + str(lane_number)
                data_source = graphic_for_library_kit (heading, 'projects in lane ' ,'Project Names', 'Number of M bases', 'ocean', yield_mb_lane)
                yield_mb_lane_graphic = FusionCharts("column3d", render_number , "500", "300", chart_number, "json", data_source)
                #
                yield_graphic = 'yield_mb_graphic' + str(lane_number)
                library_stats [yield_graphic] = yield_mb_lane_graphic.render()

                # creating the Q30 graphics
                chart_number = 'q30-chart-' + str(lane_number)
                render_number = 'q30-ex'+ str(lane_number)
                heading = 'Percent of bases > Q30 in the projects for Lane ' + str(lane_number)
                data_source = graphic_for_library_kit (heading, 'projects in lane ' ,'Project Names', 'Percent of Q 30', 'zune', q_30_lane)
                q30_lane_graphic = FusionCharts("column3d", render_number , "400", "300", chart_number, "json", data_source)
                #
                q30_graphic = 'q30_graphic' + str(lane_number)
                library_stats [q30_graphic] = q30_lane_graphic.render()

                # creating the Mean graphics
                chart_number = 'mean-chart-' + str(lane_number)
                render_number = 'mean-ex'+ str(lane_number)
                heading = 'Mean Quality Score in the projects for Lane ' + str(lane_number)
                data_source = graphic_for_library_kit (heading, 'projects in lane ' ,'Project Names', 'Percent of Q 30', 'carbon', mean_q_lane)
                mean_lane_graphic = FusionCharts("column3d", render_number , "400", "300", chart_number, "json", data_source)
                #
                mean_graphic = 'mean_graphic' + str(lane_number)
                library_stats [mean_graphic] = mean_lane_graphic.render()


            library_name = project.get_library_name()
            library_stats['library_name'] = library_name
            library_stats['project_names'] = projects_name_in_library
            #
            ########################################################################
            # set the data for the library under study
            ########################################################################
            q30_comparations , mean_comparations , n_bases_comparations = {}, {} , {}
            q30_comparations [library_name] = format(statistics.mean (q30_in_lib), '.2f')
            mean_comparations [library_name] = format(statistics.mean (mean_in_lib), '.2f')
            n_bases_comparations [library_name] = format(statistics.mean (yield_mb_in_lib), '.2f')
            error_in_library_to_compare = ''
            # get the data for the libraries to compare with
            if start_date == '' and end_date == '':
                if Projects.objects.filter(runprocess_id__state__runStateName__exact = 'Completed').exclude(libraryKit__exact = library_name).exists():
                    libraries_to_compare = Projects.objects.filter(runprocess_id__state__runStateName__exact = 'Completed').exclude(libraryKit__exact = library_name)
                else :
                    error_in_library_to_compare ='No other library have been found for doing the comparison. '

            if start_date != '' and end_date == '':
                if Projects.objects.filter(runprocess_id__state__runStateName__exact = 'Completed', generatedat__gte = start_date).exclude(libraryKit__exact = library_name).exists():
                    libraries_to_compare = Projects.objects.filter(runprocess_id__state__runStateName__exact = 'Completed', generatedat__gte = start_date).exclude(libraryKit__exact = library_name)
                else :
                    error_in_library_to_compare ='No other library have been found for doing the comparison, with the starting date  ' + start_date

            if start_date == '' and end_date != '':
                if Projects.objects.filter(runprocess_id__state__runStateName__exact = 'Completed', generatedat__lte = end_date).exclude(libraryKit__exact = library_name).exists():
                    libraries_to_compare = Projects.objects.filter(runprocess_id__state__runStateName__exact = 'Completed', generatedat__lte = end_date).exclude(libraryKit__exact = library_name)
                else :
                    error_in_library_to_compare ='No other library have been found for doing the comparison ending with  ' + end_date

            if start_date != '' and end_date != '':
                if Projects.objects.filter(runprocess_id__state__runStateName__exact = 'Completed', generatedat__range =(start_date, end_date)).exclude(libraryKit__exact = library_name).exists():
                    libraries_to_compare = Projects.objects.filter(runprocess_id__state__runStateName__exact = 'Completed', generatedat__range =(start_date, end_date)).exclude(libraryKit__exact = library_name)
                else :
                    error_in_library_to_compare ='No other library have been found for doing the comparison for the start date  ' + start_date + '  and with the ending date  ' + end_date

            if error_in_library_to_compare == '':
                for project_to_compare in libraries_to_compare :
                    library_to_compare_name = project_to_compare.get_library_name()
                    project_to_compare_id = project_to_compare.id
                    #q_30_lane , mean_q_lane , yield_mb_lane = {} , {} ,{}
                    q30_compare_lib, mean_compare_lib, yield_mb_compare_lib = [], [] , []
                    for lane_number in range (1,5):
                        lane_in_project = StatsLaneSummary.objects.get(project_id__exact = project_to_compare_id, lane__exact = lane_number)
                        q_30_value, mean_q_value, yield_mb , cluster_pf = lane_in_project.get_stats_info().split(';')
                        q30_compare_lib.append(float(q_30_value))
                        mean_compare_lib.append(float(mean_q_value))
                        yield_mb_compare_lib.append(float(yield_mb.replace(',','')))
                    if library_to_compare_name in q30_comparations:
                        q30_tmp_list =[float(q30_comparations [library_to_compare_name]), statistics.mean (q30_compare_lib)]
                        q30_comparations [library_to_compare_name] = format(statistics.mean (q30_tmp_list), '.2f')
                        mean_tmp_list = [float(mean_comparations [library_to_compare_name]), statistics.mean (mean_compare_lib)]
                        mean_comparations [library_to_compare_name] = format(statistics.mean (mean_tmp_list), '.2f')
                        n_bases_list =[float(n_bases_comparations [library_to_compare_name]), statistics.mean (yield_mb_compare_lib)]
                        n_bases_comparations [library_to_compare_name] = format(statistics.mean (n_bases_list), '.2f')
                    else:
                        q30_comparations [library_to_compare_name] = format(statistics.mean (q30_compare_lib), '.2f')
                        mean_comparations [library_to_compare_name] = format(statistics.mean (mean_compare_lib), '.2f')
                        n_bases_comparations [library_to_compare_name] = format(statistics.mean (yield_mb_compare_lib), '.2f')

            else:
                library_stats ['error_library'] = error_in_library_to_compare


            heading = 'Comparison of Percent of bases > Q30  '
            data_source = graphic_for_library_kit (heading, 'Q30 comparison ' ,'Library Names', 'Percent of Q 30', '', q30_comparations)
            comp_q30_lib_graphic = FusionCharts("column3d", 'comp-q30-1' , "500", "300", 'comp-q30-chart-1', "json", data_source)
            library_stats ['comp_q30_graphic'] = comp_q30_lib_graphic.render()

            heading = 'Comparison of Mean Quality Score '
            data_source = graphic_for_library_kit (heading, 'Mean Quality Score comparison ' ,'Library Names', 'Mean Quality Score', '', mean_comparations)
            comp_mean_lib_graphic = FusionCharts("column3d", 'comp-mean-1' , "500", "300", 'comp-mean-chart-1', "json", data_source)
            library_stats ['comp_mean_graphic'] = comp_mean_lib_graphic.render()

            heading = 'Number of Bases comparison'
            data_source = graphic_for_library_kit (heading, 'Number of Bases comparison ' ,'Library Names', 'Number of Bases ', '', n_bases_comparations)
            comp_mean_lib_graphic = FusionCharts("column3d", 'comp-n_bases-1' , "500", "300", 'comp-n_bases-chart-1', "json", data_source)
            library_stats ['comp_n_bases_graphic'] = comp_mean_lib_graphic.render()

            return render (request,'iSkyLIMS_wetlab/StatsPerLibrary.html', {'display_library_stats': library_stats })
        else:
            library_list_stats ={}
            libraries_found_name =[]
            # get the library names that match with the searching criteria
            for library in library_found :
                lib_name =library.get_library_name ()
                if not lib_name in libraries_found_name :
                    libraries_found_name.append(lib_name)
            #
            library_list_stats['library_names'] = libraries_found_name
            q30_comparations , mean_comparations , n_bases_comparations = {}, {} , {}
            ###
            # get the data for displaying the libraries found in the form request
            ###
            get_list_of_libraries_values (library_found, q30_comparations, mean_comparations , n_bases_comparations)

            heading = 'Comparison of Percent of bases > Q30  '
            data_source = graphic_for_library_kit (heading, 'Q30 comparison ' ,'Library Names', 'Percent of Q 30', '', q30_comparations)
            comp_q30_lib_graphic = FusionCharts("column3d", 'comp-q30-1' , "500", "300", 'comp-q30-chart-1', "json", data_source)
            #
            library_list_stats ['comp_q30_graphic'] = comp_q30_lib_graphic.render()

            heading = 'Comparison of Mean Quality Score '
            data_source = graphic_for_library_kit (heading, 'Mean Quality Score comparison ' ,'Library Names', 'Mean Quality Score', '', mean_comparations)
            comp_mean_lib_graphic = FusionCharts("column3d", 'comp-mean-1' , "500", "300", 'comp-mean-chart-1', "json", data_source)
            #
            library_list_stats ['comp_mean_graphic'] = comp_mean_lib_graphic.render()

            heading = 'Number of Bases comparison'
            data_source = graphic_for_library_kit (heading, 'Number of Bases comparison ' ,'Library Names', 'Number of Bases ', '', n_bases_comparations)
            comp_mean_lib_graphic = FusionCharts("column3d", 'comp-n_bases-1' , "500", "300", 'comp-n_bases-chart-1', "json", data_source)
            #
            library_list_stats ['comp_n_bases_graphic'] = comp_mean_lib_graphic.render()
            ###
            # get the data for displaying the libraries found in the form request
            ###
            all_libraries = Projects.objects.filter(runprocess_id__state__runStateName__exact = 'Completed')
            if (start_date != '' and end_date != ''):
                if all_libraries.filter(generatedat__range=(start_date, end_date)).exists():
                     library_found = library_found.filter(generatedat__range=(start_date, end_date))
            if start_date !='' and end_date == '':
                if all_libraries.filter(generatedat__gte = start_date).exists():
                     all_libraries = library_found.filter(generatedat__gte = start_date)
            if start_date =='' and end_date != '':
                if all_libraries.filter(generatedat__lte = end_date).exists():
                    #
                    all_libraries = library_found.filter(generatedat__lte = end_date)

            q30_comparations , mean_comparations , n_bases_comparations = {}, {} , {}
            get_list_of_libraries_values (all_libraries, q30_comparations, mean_comparations , n_bases_comparations)
            #
            heading = 'Library kits of Percent of bases > Q30  '
            data_source = graphic_for_library_kit (heading, 'Q30 library kits ' ,'Library Names', 'Percent of Q 30', '', q30_comparations)
            lib_q30_lib_graphic = FusionCharts("column3d", 'lib-q30-lib' , "500", "300", 'lib-q30-chart-1', "json", data_source)
            #
            library_list_stats ['lib_q30_graphic'] = lib_q30_lib_graphic.render()

            heading = 'Library kits of Mean Quality Score '
            data_source = graphic_for_library_kit (heading, 'Mean Quality Score Library kits ' ,'Library Names', 'Mean Quality Score', '', mean_comparations)
            lib_mean_lib_graphic = FusionCharts("column3d", 'lib-mean-lib' , "500", "300", 'lib-mean-chart-1', "json", data_source)
            #
            library_list_stats ['lib_mean_graphic'] = lib_mean_lib_graphic.render()

            heading = 'Number of Bases per Library kits'
            data_source = graphic_for_library_kit (heading, 'Number of Bases per Library kits ' ,'Library Names', 'Number of Bases ', '', n_bases_comparations)
            lib_mean_lib_graphic = FusionCharts("column3d", 'lib-n_bases-lib' , "500", "300", 'lib-n_bases-chart-1', "json", data_source)
            #
            library_list_stats ['lib_n_bases_graphic'] = lib_mean_lib_graphic.render()

            # Create the graphic for number of time that library has been used

            count_libraries = {}
            for library_used in all_libraries :
                lib_name = library_used.get_library_name()
                if not lib_name in count_libraries :
                    count_libraries[lib_name] = 1
                else:
                    count_libraries[lib_name] +=1
            data_source = pie_graphic ('Library utilization in projects', 'fint',count_libraries)
            libraries_kit_utilization = FusionCharts("pie3d", "lib_kit_utilization_graph-1" , "500", "400", "lib_kit_utilization_chart-1", "json", data_source)
            library_list_stats ['libraries_kit_utilization'] = libraries_kit_utilization.render()

            return render (request,'iSkyLIMS_wetlab/StatsPerLibrary.html', {'display_list_of_library_stats': library_list_stats })

    else:
        return render (request,'iSkyLIMS_wetlab/StatsPerLibrary.html')

@login_required
def annual_report (request) :
    # check user privileges
    if request.user.is_authenticated:
        try:
            groups = Group.objects.get(name='WetlabManager')
            if groups not in request.user.groups.all():
                return render (request,'iSkyLIMS_wetlab/error_page.html', {'content':['You do have the enough privileges to see this page ','Contact with your administrator .']})
        except:
            return render (request,'iSkyLIMS_wetlab/error_page.html', {'content':['You do have the enough privileges to see this page ','Contact with your administrator .']})
    else:
        #redirect to login webpage
        return redirect ('/accounts/login')

    if request.method=='POST' :
        year_selected = int(request.POST['yearselected'])
        # get the current year to compare with the input
        present_year = datetime.datetime.now().year
        if year_selected > present_year:
            return render (request,'iSkyLIMS_wetlab/error_page.html', {'content':['Annual Report cannot be done on the future  ',
                            'the input year in the Form  ',year_selected , 'is not allowed']})

        completed_run_in_year = RunProcess.objects.filter(run_date__year = year_selected, state__runStateName__exact = 'Completed')
        #
        uncompleted_run_in_year = RunProcess.objects.filter(run_date__year = year_selected).exclude(state__runStateName__exact = 'Completed')
        if len (completed_run_in_year)  == 0 and len (uncompleted_run_in_year) == 0:
            return render (request,'iSkyLIMS_wetlab/error_page.html', {'content':['Annual Report cannot be generated because there is no runs performed the year ', year_selected ]})

        annual_report_information = {}
        annual_report_information['year'] = year_selected
        number_of_runs = {}
        number_of_runs['Completed Runs'] = 0
        number_of_runs['Not Finish Runs'] = 0
        if len ( completed_run_in_year) > 0 :
            completed_run = []
            for run in completed_run_in_year :
                completed_run.append(run.get_run_name)
            annual_report_information['completed_run'] = completed_run
            number_of_runs['Completed Runs'] = len ( completed_run_in_year)
        if len ( uncompleted_run_in_year) > 0 :
            uncompleted_run = []
            for run_uncompleted in uncompleted_run_in_year :
                uncompleted_run.append(run_uncompleted.get_run_name)
            annual_report_information['uncompleted_run'] = uncompleted_run
            number_of_runs['Not Finish Runs'] = len ( uncompleted_run_in_year)
        # prepare the pie graphic for the number of completed/ unfinished runs
        data_source = pie_graphic_standard('Number of Runs performed on the year', "",'ocean',number_of_runs)
        graphic_completed_run = FusionCharts("pie3d", "ex1" , "400", "300", "chart-1", "json", data_source)
        annual_report_information ['graphic_completed_run'] = graphic_completed_run.render()

        #
        ### Collecting information from StatsRunSummary
        run_found_bin_summary_year = StatsRunSummary.objects.filter(stats_summary_run_date__year = year_selected, level__exact = 'Total')
        q30_year, aligned_year, error_rate_year  = {} , {} , {}
        for run_bin_summary in run_found_bin_summary_year :
            bin_summary_data = run_bin_summary.get_bin_run_summary().split(';')
            run_name = run_bin_summary.runprocess_id.get_run_name()
            aligned_year[run_name]= bin_summary_data[2]
            error_rate_year[run_name]= bin_summary_data[3]
            q30_year[run_name]= bin_summary_data[5]
        annual_report_information ['aligned_data'] = aligned_year
        annual_report_information ['error_rate_data'] = error_rate_year
        annual_report_information ['q30_data'] = q30_year
        # graphics for StatsRunSummary
        heading = 'Aligned % for the runs done on year '+ str(year_selected )
        data_source = column_graphic_for_year_report (heading, 'Aligned  ' , 'Run names ', 'Aligned (in %)', 'ocean', aligned_year)
        aligned_year_graphic = FusionCharts("column3d", 'aligned_year' , "600", "300", 'aligned_chart-3', "json", data_source)
        annual_report_information ['aligned_graphic'] = aligned_year_graphic.render()

        heading = 'Error Rate for the runs done on year '+ str(year_selected )
        data_source = column_graphic_for_year_report (heading, 'Error rate ' , 'Run names ', 'Error rate', 'carbon', error_rate_year)
        error_rate_year_graphic = FusionCharts("column3d", 'error_rate_year' , "600", "300", 'error_rate_chart-4', "json", data_source)
        annual_report_information ['error_rate_graphic'] = error_rate_year_graphic.render()

        heading = '>Q30 for the runs done on year '+ str(year_selected )
        data_source = column_graphic_for_year_report (heading, 'Q30  ' , 'Run names ', '>Q 30 (in %)', 'fint', q30_year)
        q30_year_graphic = FusionCharts("column3d", 'q30_year' , "600", "300", 'q30_chart-2', "json", data_source)
        #
        annual_report_information ['q30_graphic'] = q30_year_graphic.render()
        #

        # Get the information for investigator name and the projects done
        # number_proyects_investigator contains a dict with 3 ranges 1-5, 6-10, more than 11
        investigator_projects = Projects.objects.filter(project_run_date__year = year_selected).order_by('user_id')
        project_by_user = {}
        investigator_5_project, investigator_10_project, investigator_more_10_project = {}, {} , {}
        #
        for investigator in investigator_projects:
            user_name = investigator.get_user_name()
            if user_name in project_by_user:
                project_by_user [user_name].append(investigator.get_project_name())
            else:
                project_by_user [user_name]=([investigator.get_project_name()])
        for key, value in project_by_user.items():
            if len(value) <= 5 :
                investigator_5_project[key]= value
            elif len (value) <=10:
                investigator_10_project[key]= value
            else:
                investigator_more_10_project[key]= value
        annual_report_information['user_5_projects'] = investigator_5_project
        annual_report_information['user_10_projects'] = investigator_10_project
        annual_report_information['user_more_10_projects'] = investigator_more_10_project

        # Create the bar graphic for user projects
        p_user_year ={}
        p_user_year['1 - 5']= len(investigator_5_project)
        p_user_year['6 - 10']= len(investigator_10_project)
        p_user_year['more than 10']= len(investigator_more_10_project)
        heading = 'Projects done per investigator on year '+ str(year_selected )
        data_source = column_graphic_for_year_report (heading, '  ' , 'Projects ', 'number of users', 'ocean', p_user_year)
        p_user_year_graphic = FusionCharts("column3d", 'bar_project_user_year' , "400", "300", 'p_user_chart-1', "json", data_source)
        annual_report_information ['p_user_year_graphic'] = p_user_year_graphic.render()

        data_source = pie_graphic_standard (heading, 'Percentage' ,'carbon', p_user_year)
        pie_p_user_year_graphic = FusionCharts("pie3d", "pie_project_user_year" , "400", "300", "p_user_chart-2", "json", data_source)
        annual_report_information ['pie_p_user_year_graphic'] = pie_p_user_year_graphic.render()
        #
        return render (request, 'iSkyLIMS_wetlab/AnnualReport.html',{'display_annual_report': annual_report_information})
    else:
        return render (request, 'iSkyLIMS_wetlab/AnnualReport.html')

@login_required
def monthly_report (request) :
    # check user privileges
    if request.user.is_authenticated:
        try:
            groups = Group.objects.get(name='WetlabManager')
            if groups not in request.user.groups.all():
                return render (request,'iSkyLIMS_wetlab/error_page.html', {'content':['You do have the enough privileges to see this page ','Contact with your administrator .']})
        except:
            return render (request,'iSkyLIMS_wetlab/error_page.html', {'content':['You do have the enough privileges to see this page ','Contact with your administrator .']})
    else:
        #redirect to login webpage
        return redirect ('/accounts/login')

    if request.method=='POST' :

        input_value = request.POST['month_year_selected']
        browser_used = request.META['HTTP_USER_AGENT']
        if 'Firefox' in browser_used :
            try:
                datetime.datetime.strptime(input_value, '%m-%Y')
                month_selected, year_selected = input_value.split('-')
            except:
                return render (request,'iSkyLIMS_wetlab/error_page.html', {'content':['Input field does not have the right format  ',
                            'the right input format is MM-YYYY   the entry ', input_value , ' is not allowed']})

        else:
            try:
                datetime.datetime.strptime(input_value, '%Y-%m')
                year_selected , month_selected = input_value.split('-')
            except:
                return render (request,'iSkyLIMS_wetlab/error_page.html', {'content':['Monthly Report input field does not have the right format  ',
                            'the right input format is MM-YYYY  ' ,' the entry ', input_value , ' is not allowed']})

        # get the current year to compare with the input
        present_year = datetime.datetime.now().year
        #
        if (int(year_selected) > present_year) :
            return render (request,'iSkyLIMS_wetlab/error_page.html', {'content':['Monthly Report cannot be done on the future  ',
                            'the input year in the Form  ', year_selected , 'is not allowed']})

        present_month = datetime.datetime.now().month
        if (int(year_selected) == present_year) and (int(month_selected) > present_month) :
            return render (request,'iSkyLIMS_wetlab/error_page.html', {'content':['Monthly Report cannot be done on the future  ',
                            'the input month in the Form  ', month_selected , 'is not allowed']})

        completed_run_in_year_month = RunProcess.objects.filter(run_date__year = year_selected,  run_date__month = month_selected ,state__runStateName__exact = 'Completed')
        #
        uncompleted_run_in_year_month = RunProcess.objects.filter(run_date__year = year_selected, run_date__month = month_selected).exclude(state__runStateName__exact = 'Completed')
        if len (completed_run_in_year_month)  == 0 and len (uncompleted_run_in_year_month) == 0:
            return render (request,'iSkyLIMS_wetlab/error_page.html', {'content':['Montly Report cannot be generated because there is no runs performed the year ', year_selected ]})

        monthly_report_information = {}
        monthly_report_information['month_year'] = str(month_selected + '  ' +  year_selected )
        number_of_runs = {}
        number_of_runs['Completed Runs'] = 0
        number_of_runs['Not Finish Runs'] = 0
        if len ( completed_run_in_year_month) > 0 :
            completed_run = []
            for run in completed_run_in_year_month :
                completed_run.append(run.get_run_name)
            monthly_report_information['completed_run'] = completed_run
            number_of_runs['Completed Runs'] = len ( completed_run_in_year_month)
        if len ( uncompleted_run_in_year_month) > 0 :
            uncompleted_run = []
            for run_uncompleted in uncompleted_run_in_year_month :
                uncompleted_run.append(run_uncompleted.get_run_name)
            monthly_report_information['uncompleted_run'] = uncompleted_run
            number_of_runs['Not Finish Runs'] = len ( uncompleted_run_in_year_month)
        # prepare the pie graphic for the number of completed/ unfinished runs
        heading = str ('Graphics of the Runs performed on the ' + month_selected + ' - ' + year_selected)
        data_source = pie_graphic_standard(heading, "",'ocean',number_of_runs)
        graphic_completed_run = FusionCharts("pie3d", "ex1" , "400", "300", "chart-1", "json", data_source)
        monthly_report_information ['graphic_completed_run'] = graphic_completed_run.render()

        # Get the information for investigator name and the projects done
        # number_proyects_investigator contains a dict with 3 ranges 1, 2, more than 2
        investigator_projects = Projects.objects.filter(project_run_date__year = year_selected, project_run_date__month = month_selected).order_by('user_id')
        project_by_user = {}
        investigator_1_project, investigator_2_projects, investigator_more_2_projects = {}, {} , {}
        #
        for investigator in investigator_projects:
            user_name = investigator.get_user_name()
            if user_name in project_by_user:
                project_by_user [user_name].append(investigator.get_project_name())
            else:
                project_by_user [user_name]=([investigator.get_project_name()])
        for key, value in project_by_user.items():

            if len(value) == 1 :
                investigator_1_project[key]= value
            elif len (value) == 2:
                investigator_2_projects[key]= value
            else:
                investigator_more_2_projects[key]= value
        monthly_report_information['user_1_project'] = investigator_1_project
        monthly_report_information['user_2_projects'] = investigator_2_projects
        monthly_report_information['user_more_2_projects'] = investigator_more_2_projects

        # Create the bar graphic for user projects
        p_user_month ={}
        p_user_month['1 project']= len(investigator_1_project)
        p_user_month['2 projects']= len(investigator_2_projects)
        p_user_month['more than 2']= len(investigator_more_2_projects)

        heading = 'Projects done per investigator on '+ str(month_selected + ' - ' + year_selected )
        data_source = column_graphic_for_year_report (heading, '  ' , 'Projects ', 'number of users', 'ocean', p_user_month)
        p_user_monthly_graphic = FusionCharts("column3d", 'bar_project_user_month' , "400", "300", 'p_user_chart-1', "json", data_source)
        monthly_report_information ['p_user_monthly_graphic'] = p_user_monthly_graphic.render()

        data_source = pie_graphic_standard (heading, 'Percentage' ,'carbon', p_user_month)
        pie_p_user_monthly_graphic = FusionCharts("pie3d", "pie_project_user_month" , "400", "300", "p_user_chart-2", "json", data_source)
        monthly_report_information ['pie_p_user_monthly_graphic'] = pie_p_user_monthly_graphic.render()

        ### Collecting information from StatsRunSummary
        run_found_bin_summary_month = StatsRunSummary.objects.filter(stats_summary_run_date__year = year_selected, stats_summary_run_date__month = month_selected, level__exact = 'Total')
        q30_month, aligned_month, error_rate_month  = {} , {} , {}
        for run_bin_summary in run_found_bin_summary_month :
            bin_summary_data = run_bin_summary.get_bin_run_summary().split(';')
            run_name = run_bin_summary.runprocess_id.get_run_name()
            aligned_month[run_name]= bin_summary_data[2]
            error_rate_month[run_name]= bin_summary_data[3]
            q30_month[run_name]= bin_summary_data[5]
        monthly_report_information ['aligned_data'] = aligned_month
        monthly_report_information ['error_rate_data'] = error_rate_month
        monthly_report_information ['q30_data'] = q30_month
        # graphics for StatsRunSummary
        heading = 'Aligned % for the runs done on '+ str(month_selected + ' - ' + year_selected)
        data_source = column_graphic_for_year_report (heading, 'Aligned  ' , 'Run names ', 'Aligned (in %)', 'ocean', aligned_month)
        aligned_month_graphic = FusionCharts("column3d", 'aligned_year' , "600", "300", 'aligned_chart-3', "json", data_source)
        monthly_report_information ['aligned_graphic'] = aligned_month_graphic.render()

        heading = 'Error Rate for the runs done on  '+ str(month_selected + ' - ' + year_selected)
        data_source = column_graphic_for_year_report (heading, 'Error rate ' , 'Run names ', 'Error rate', 'carbon', error_rate_month)
        error_rate_month_graphic = FusionCharts("column3d", 'error_rate_year' , "600", "300", 'error_rate_chart-4', "json", data_source)
        monthly_report_information ['error_rate_graphic'] = error_rate_month_graphic.render()

        heading = '>Q30 for the runs done on  '+ str(month_selected + ' - ' + year_selected)
        data_source = column_graphic_for_year_report (heading, 'Q30  ' , 'Run names ', '>Q 30 (in %)', 'fint', q30_month)
        q30_month_graphic = FusionCharts("column3d", 'q30_year' , "600", "300", 'q30_chart-2', "json", data_source)

        monthly_report_information ['q30_graphic'] = q30_month_graphic.render()

        return render (request, 'iSkyLIMS_wetlab/MonthlyReport.html',{'display_monthly_report': monthly_report_information})
    else:
        return render (request, 'iSkyLIMS_wetlab/MonthlyReport.html')

@login_required
def quarter_report (request) :
    # check user privileges
    if request.user.is_authenticated:
        try:
            groups = Group.objects.get(name='WetlabManager')
            if groups not in request.user.groups.all():
                return render (request,'iSkyLIMS_wetlab/error_page.html', {'content':['You do have the enough privileges to see this page ','Contact with your administrator .']})
        except:
            return render (request,'iSkyLIMS_wetlab/error_page.html', {'content':['You do have the enough privileges to see this page ','Contact with your administrator .']})
    else:
        #redirect to login webpage
        return redirect ('/accounts/login')

    if request.method=='POST' :
        year_selected = request.POST['yearselected']
        quarter_selected = int(request.POST['quarter'])
        quarter_string = ['', 'First Quarter (January -- March) ', 'Second Quarter (April -- June) ',
                            'Third Quarter (July -- September) ', 'Fourth Quarter (October -- Decemmber) ' ]
        days_in_end_quarter = ['0','31','30','30','31']
        start_quarter = str(quarter_selected *3 -2)
        end_quarter = str(quarter_selected *3)
        start_date = str(year_selected + '-' + start_quarter + '-01')
        end_date = str(year_selected + '-' + end_quarter + '-' + days_in_end_quarter[quarter_selected])
        # get the current year to compare with the input
        present_year = datetime.datetime.now().year
        if int (year_selected) > present_year:
            return render (request,'iSkyLIMS_wetlab/error_page.html', {'content':['Quarter Report cannot be done on the future  ',
                            'the input year in the Form  ',year_selected , 'is not allowed']})

        present_month = datetime.datetime.now().month
        if (int(year_selected) == present_year) and (int(end_quarter) > present_month) :
            return render (request,'iSkyLIMS_wetlab/error_page.html', {'content':['Quater Report cannot be done on the future  ',
                            'the selected Quarter ', quarter_string [quarter_selected] + str(year_selected) , 'is not allowed']})

        #
        completed_run_in_quarter = RunProcess.objects.filter( run_date__range =(start_date, end_date) , state__runStateName = 'Completed')
        #
        uncompleted_run_in_quarter = RunProcess.objects.filter(run_date__range =(start_date, end_date)).exclude(state__runStateName = 'Completed')
        if len (completed_run_in_quarter)  == 0 and len (uncompleted_run_in_quarter) == 0:
            return render (request,'iSkyLIMS_wetlab/error_page.html', {'content':['Quater Report cannot be generated because there is no runs performed the Quarter ',
                            quarter_string [quarter_selected] + str(year_selected) ]})

        quarter_report_information = {}
        quarter_report_information['quarter_year'] = quarter_string [quarter_selected] + str(year_selected)
        number_of_runs = {}
        number_of_runs['Completed Runs'] = 0
        number_of_runs['Not Finish Runs'] = 0
        if len ( completed_run_in_quarter) > 0 :
            completed_run = []
            for run in completed_run_in_quarter :
                completed_run.append(run.get_run_name)
            quarter_report_information['completed_run'] = completed_run
            number_of_runs['Completed Runs'] = len ( completed_run_in_quarter)
        if len ( uncompleted_run_in_quarter) > 0 :
            uncompleted_run = []
            for run_uncompleted in uncompleted_run_in_quarter :
                uncompleted_run.append(run_uncompleted.get_run_name)
            quarter_report_information['uncompleted_run'] = uncompleted_run
            number_of_runs['Not Finish Runs'] = len ( uncompleted_run_in_quarter)
        # prepare the pie graphic for the number of completed/ unfinished runs
        data_source = pie_graphic_standard('Number of Runs performed on the year', "",'ocean',number_of_runs)
        graphic_completed_run = FusionCharts("pie3d", "ex1" , "400", "300", "chart-1", "json", data_source)
        quarter_report_information ['graphic_completed_run'] = graphic_completed_run.render()

        #
        ### Collecting information from StatsRunSummary
        run_found_bin_summary_quarter = StatsRunSummary.objects.filter(stats_summary_run_date__range = (start_date, end_date), level__exact = 'Total')
        q30_quarter, aligned_quarter, error_rate_quarter  = {} , {} , {}
        for run_bin_summary in run_found_bin_summary_quarter :
            bin_summary_data = run_bin_summary.get_bin_run_summary().split(';')
            run_name = run_bin_summary.runprocess_id.get_run_name()
            aligned_quarter[run_name]= bin_summary_data[2]
            error_rate_quarter[run_name]= bin_summary_data[3]
            q30_quarter[run_name]= bin_summary_data[5]
        quarter_report_information ['aligned_data'] = aligned_quarter
        quarter_report_information ['error_rate_data'] = error_rate_quarter
        quarter_report_information ['q30_data'] = q30_quarter
        # graphics for StatsRunSummary
        heading = 'Aligned % for the runs done on  ' + quarter_string [quarter_selected] + str(year_selected)
        data_source = column_graphic_for_year_report (heading, 'Aligned  ' , 'Run names ', 'Aligned (in %)', 'ocean', aligned_quarter)
        aligned_quarter_graphic = FusionCharts("column3d", 'aligned_year' , "600", "300", 'aligned_chart-3', "json", data_source)
        quarter_report_information ['aligned_graphic'] = aligned_quarter_graphic.render()

        heading = 'Error Rate for the runs done on year '+ quarter_string [quarter_selected] + str(year_selected)
        data_source = column_graphic_for_year_report (heading, 'Error rate ' , 'Run names ', 'Error rate', 'carbon', error_rate_quarter)
        error_rate_quarter_graphic = FusionCharts("column3d", 'error_rate_year' , "600", "300", 'error_rate_chart-4', "json", data_source)
        quarter_report_information ['error_rate_graphic'] = error_rate_quarter_graphic.render()

        heading = '>Q30 for the runs done on year '+ quarter_string [quarter_selected] + str(year_selected)
        data_source = column_graphic_for_year_report (heading, 'Q30  ' , 'Run names ', '>Q 30 (in %)', 'fint', q30_quarter)
        q30_quarter_graphic = FusionCharts("column3d", 'q30_year' , "600", "300", 'q30_chart-2', "json", data_source)
        #
        quarter_report_information ['q30_graphic'] = q30_quarter_graphic.render()
        #

        # Get the information for investigator name and the projects done
        # number_proyects_investigator contains a dict with 3 ranges 1-5, 6-10, more than 11
        investigator_projects = Projects.objects.filter(project_run_date__range = (start_date, end_date)).order_by('user_id')
        project_by_user = {}
        investigator_5_project, investigator_10_project, investigator_more_10_project = {}, {} , {}
        #
        for investigator in investigator_projects:
            user_name = investigator.get_user_name()
            if user_name in project_by_user:
                project_by_user [user_name].append(investigator.get_project_name())
            else:
                project_by_user [user_name]=([investigator.get_project_name()])
        for key, value in project_by_user.items():
            if len(value) <= 5 :
                investigator_5_project[key]= value
            elif len (value) <=10:
                investigator_10_project[key]= value
            else:
                investigator_more_10_project[key]= value
        quarter_report_information['user_5_projects'] = investigator_5_project
        quarter_report_information['user_10_projects'] = investigator_10_project
        quarter_report_information['user_more_10_projects'] = investigator_more_10_project

        # Create the bar graphic for user projects
        p_user_quarter ={}
        p_user_quarter['1 - 5']= len(investigator_5_project)
        p_user_quarter['6 - 10']= len(investigator_10_project)
        p_user_quarter['more than 10']= len(investigator_more_10_project)
        heading = 'Projects done per investigator on year '+ str(year_selected )
        data_source = column_graphic_for_year_report (heading, '  ' , 'Projects ', 'number of users', 'ocean', p_user_quarter)
        p_user_quarter_graphic = FusionCharts("column3d", 'bar_project_user_year' , "400", "300", 'p_user_chart-1', "json", data_source)
        quarter_report_information ['p_user_year_graphic'] = p_user_quarter_graphic.render()

        data_source = pie_graphic_standard (heading, 'Percentage' ,'carbon', p_user_quarter)
        pie_p_user_quarter_graphic = FusionCharts("pie3d", "pie_project_user_year" , "400", "300", "p_user_chart-2", "json", data_source)
        quarter_report_information ['pie_p_user_year_graphic'] = pie_p_user_quarter_graphic.render()
        #
        return render (request, 'iSkyLIMS_wetlab/QuarterReport.html',{'display_quarter_report': quarter_report_information})
    else:
        return render (request, 'iSkyLIMS_wetlab/QuarterReport.html')

'''
def open_samba_connection ():

    from smb.SMBConnection import SMBConnection
    ##conn=SMBConnection('bioinfocifs', 'fCdEg979I-W.gUx-teDr', 'NGS_Data', 'quibitka', use_ntlm_v2=True)
    conn=SMBConnection(wetlab_config.SAMBA_USER_ID, wetlab_config.SAMBA_USER_PASSWORD, wetlab_config.SAMBA_SHARED_FOLDER_NAME,wetlab_config.SAMBA_REMOTE_SERVER_NAME, use_ntlm_v2=True)
    ##conn.connect('172.21.7.11', 445)
    conn.connect(wetlab_config.SAMBA_IP_SERVER, 445)
    return conn
'''
def get_size_dir (directory, conn, ):
    count_file_size = 0
    file_list = conn.listPath(wetlab_config.SAMBA_SHARED_FOLDER_NAME, directory)
    for sh_file in file_list:
        if sh_file.isDirectory:
            if (sh_file.filename == '.' or sh_file.filename == '..'):
                continue

            sub_directory = os.path.join (directory,sh_file.filename)
            count_file_size += get_size_dir (sub_directory, conn)
        else:
            count_file_size += sh_file.file_size

    return count_file_size




def update_tables (request):
    #### Update the run date for the projects. StatsBinRunRead and  StatsRunSummary
    #### tables when they were not updated. It takes the run date from the run date
    '''
    run_founds = RunProcess.objects.all()
    for run in run_founds :
        run_id = run.id
        run_date = run.run_date
        projects_to_update = Projects.objects.filter(runprocess_id__exact = run_id)
        for project in projects_to_update :
            project.project_run_date = run_date
            project.save()
        stats_run_to_update = StatsRunSummary.objects.filter(runprocess_id__exact = run_id)
        for stats_run in stats_run_to_update :
            stats_run.stats_summary_run_date = run_date
            stats_run.save()
        stats_read_to_update = StatsBinRunRead.objects.filter(runprocess_id__exact = run_id)
        for  stats_read in stats_read_to_update :
            stats_read.stats_read_run_date = run_date
            stats_read.save()
    return render(request, 'iSkyLIMS_wetlab/info_page.html', {'content':['The tables have been updated']})
    '''
    ### Update the disc space used of each run
    ### It will connect to quibitka to get the size of the file for each run


    #conn=open_samba_connection()
    if RunProcess.objects.filter(state__runStateName ='Completed', useSpaceImgMb = 0).exists():
        conn = open_samba_connection()
        run_list_be_updated = RunProcess.objects.filter(state__runStateName = 'Completed' , useSpaceImgMb =0 )
        for run_be_updated in run_list_be_updated:
            run_id = run_be_updated.id
            run_parameter_id=RunningParameters.objects.get(pk=run_id)

            runID_value = run_parameter_id.RunID
            get_full_list = conn.listPath(wetlab_config.SAMBA_SHARED_FOLDER_NAME ,runID_value)
            rest_of_dir_size = 0
            data_dir_size = 0
            images_dir_size = 0
            in_mega_bytes = 1024*1024
            #
            for item_list in get_full_list:
                if item_list.filename == '.' or item_list.filename == '..':
                    continue
                if item_list.filename == 'Data':
                    dir_data = os.path.join(runID_value,'Data')
                    data_dir_size = get_size_dir(dir_data , conn)
                    continue

                elif item_list.filename == 'Images':
                    dir_images = os.path.join(runID_value, 'Images')
                    images_dir_size = get_size_dir(dir_images , conn)
                    continue

                if item_list.isDirectory:
                    item_dir = os.path.join(runID_value, item_list.filename)
                    rest_of_dir_size += get_size_dir(item_dir, conn)
                else:
                    rest_of_dir_size += item_list.file_size
            #
            # format file space and save it into database
            data_dir_size_formated = '{0:,}'.format(round(data_dir_size/in_mega_bytes))
            images_dir_size_formated = '{0:,}'.format(round(images_dir_size/in_mega_bytes))
            rest_of_dir_size_formated = '{0:,}'.format(round(rest_of_dir_size/in_mega_bytes))
            run_be_updated.useSpaceImgMb= images_dir_size_formated
            run_be_updated.useSpaceFastaMb= data_dir_size_formated
            run_be_updated.useSpaceOtherMb= rest_of_dir_size_formated
            #
            run_be_updated.save()

        '''

        get_full_list = conn.listPath('NGS_Data' ,run_name)
        rest_of_dir_size = 0
        data_dir_size = 0
        images_dir_size = 0


        conn.close()

        '''
        return render(request, 'iSkyLIMS_wetlab/info_page.html', {'content':['The Disk space usage have been updated']})
    else:
        return render(request, 'iSkyLIMS_wetlab/error_page.html', {'content':['There is no tables which requiered to update with Disk space usage information']})

def update_tables_date (request):
    if RunProcess.objects.filter(state__runStateName ='Completed', run_finish_date = None).exists():
        #
        conn = open_samba_connection()
        run_list_be_updated = RunProcess.objects.filter(state__runStateName = 'Completed' , run_finish_date = None )
        for run_be_updated in run_list_be_updated:
            run_id = run_be_updated.id
            run_parameter_id=RunningParameters.objects.get(pk=run_id)
            runID_value = run_parameter_id.RunID
            completion_file = os.path.join(runID_value, 'RunCompletionStatus.xml')
            try:
                completion_attributes = conn.getAttributes(wetlab_config.SAMBA_SHARED_FOLDER_NAME ,completion_file)
                # fetching the time creation on the RunCompletionStatus.xml for Run finish datetime
                run_be_updated.run_finish_date = datetime.datetime.fromtimestamp(int(completion_attributes.create_time)).strftime('%Y-%m-%d %H:%M:%S')
            except:
                pass
            conversion_stats_file = os.path.join (runID_value,'Data/Intensities/BaseCalls/Stats/', 'ConversionStats.xml')
            try:
                conversion_attributes = conn.getAttributes(wetlab_config.SAMBA_SHARED_FOLDER_NAME ,conversion_stats_file)
                #
                run_be_updated.bcl2fastq_finish_date = datetime.datetime.fromtimestamp(int(conversion_attributes.create_time)).strftime('%Y-%m-%d %H:%M:%S')
            except:
                pass
            finish_process_date = StatsRunSummary.objects.filter(runprocess_id__exact = run_id)
            run_be_updated.process_completed_date = finish_process_date[0].generatedat

            run_be_updated.save()

        return render(request, 'iSkyLIMS_wetlab/info_page.html', {'content':['The dates for the Runs have been updated']})
    else:
        return render(request, 'iSkyLIMS_wetlab/error_page.html', {'content':['There is no tables which requiered to update with date information']})


@login_required
def configuration_test (request):
    # check user privileges
    if request.user.is_authenticated:
        #import pdb; pdb.set_trace()
        if not request.user.is_staff or not request.user.is_superuser:
            return render (request,'iSkyLIMS_wetlab/error_page.html', {'content':['You do have the enough privileges to see this page ','Contact with your administrator .']})
    else:
        #redirect to login webpage
        return redirect ('/accounts/login')
    if request.method=='POST' and request.POST['action'] == 'basicTest':
        test_results = {}
        wetlab_config_file = os.path.join(settings.BASE_DIR, 'iSkyLIMS_wetlab', 'wetlab_config.py')
        test_results['iSkyLIMS_settings'] = get_iSkyLIMS_settings()
        test_results['config_file'] = get_config_file(wetlab_config_file)
        test_results['attr_files'] = get_files_attribute(os.path.join(settings.MEDIA_ROOT, 'wetlab'))
        test_results['database_access'] = check_access_database()
        test_results['samba_connection'] = check_samba_connection()

        test_results['basic_checks_ok'] = 'OK'
        #if test_results['config_file']  and test_results['attr_files']  and test_results['database_access'] and test_results['samba_connection']:
        for result in test_results :
            if test_results[result] == 'NOK':
                test_results['basic_checks_ok'] = 'NOK'
                break

        return render (request,'iSkyLIMS_wetlab/ConfigurationTest.html', {'test_results': test_results})
        ##############################
        ###### NextSeq Test ##########
        ##############################
    elif request.method=='POST' and request.POST['action'] == 'runNextSeq':
        if 'Delete' in request.POST :
            delete_test_run ('NextSeq_Test_0001')
            return render(request,'iSkyLIMS_wetlab/ConfigurationTest.html')



        runNextSeq_results = {}
        log_trace = []
        working_path = settings.MEDIA_ROOT
        os.chdir(working_path)
        config_file = os.path.join(settings.BASE_DIR,'iSkyLIMS_wetlab', 'tests', 'logging_test_config.ini' )
        log_file = get_log_file_name(config_file)
        if os.path.isfile (log_file):
            os.remove(log_file)
        logger=open_log(config_file)

        logger.info('###########---Start Testing NextSeq Run  -----############')
        # create run in Recorded state for testing
        test_run_remote_folder = 'NextSeq_Test'
        experiment_name = 'NextSeq_Test_0001'
        runNextSeq_results['CreateRun'] , result_ok = create_run_test_nextseq_in_recorded(test_run_remote_folder, experiment_name )

        if result_ok == 'NOK' :
            with open (log_file, 'r') as fh :
                for line in fh :
                    line = line.replace('\n', '')
                    log_trace.append(line)

            return render (request,'iSkyLIMS_wetlab/ConfigurationTest.html', {'runNextSeq_results': runNextSeq_results,
                                                    'log_trace': log_trace, 'basic_checks_ok' : 'OK'})
        else:
            runNextSeq_results['create_run_ok'] =  'OK'
        # Start testing on recorded state
        runNextSeq_results['Recorded'] , result_ok = run_nextseq_test_rec_to_sample_sent(test_run_remote_folder, experiment_name)

        if result_ok == 'NOK' :
            with open (log_file, 'r') as fh :
                for line in fh :
                    line = line.replace('\n', '')
                    log_trace.append(line)
            #import pdb; pdb.set_trace()
            return render (request,'iSkyLIMS_wetlab/ConfigurationTest.html', {'runNextSeq_results': runNextSeq_results,
                                                    'log_trace': log_trace, 'basic_checks_ok' : 'OK'})
        else:
            runNextSeq_results['recorded_ok'] =  'OK'

        # Processing Run
        runNextSeq_results['Sample_Sent'] , result_ok = run_nextseq_test_sample_sent_to_Processing_Run (experiment_name)
        if result_ok == 'NOK' :
            with open (log_file, 'r') as fh :
                for line in fh :
                    line = line.replace('\n', '')
                    log_trace.append(line)

            return render (request,'iSkyLIMS_wetlab/ConfigurationTest.html', {'runNextSeq_results': runNextSeq_results,
                                                    'log_trace': log_trace, 'basic_checks_ok' : 'OK'})
        else:
            runNextSeq_results['sample_sent_ok'] =  'OK'

        # Processing Run
        runNextSeq_results['Processing_Run'] , result_ok = run_nextseq_test_Processing_Run_to_Processed_Run (experiment_name)
        if result_ok == 'NOK' :
            with open (log_file, 'r') as fh :
                for line in fh :
                    line = line.replace('\n', '')
                    log_trace.append(line)

            return render (request,'iSkyLIMS_wetlab/ConfigurationTest.html', {'runNextSeq_results': runNextSeq_results,
                                                    'log_trace': log_trace, 'basic_checks_ok' : 'OK'})
        else:
            runNextSeq_results['processing_run_ok'] =  'OK'

        # Processed Run
        runNextSeq_results['Processed_Run'] , result_ok = run_test_Processed_Run_to_Processing_Bcl2fastq (experiment_name)
        if result_ok == 'NOK' :
            with open (log_file, 'r') as fh :
                for line in fh :
                    line = line.replace('\n', '')
                    log_trace.append(line)

            return render (request,'iSkyLIMS_wetlab/ConfigurationTest.html', {'runNextSeq_results': runNextSeq_results,
                                                    'log_trace': log_trace, 'basic_checks_ok' : 'OK'})
        else:
            runNextSeq_results['processed_run_ok'] =  'OK'

        # Processing Bcl2fastq
        runNextSeq_results['Processing_Bcl2fastq'] , result_ok = run_test_Processing_Bcl2fastq_to_Processed_Bcl2fastq (experiment_name)
        if result_ok == 'NOK' :
            with open (log_file, 'r') as fh :
                for line in fh :
                    line = line.replace('\n', '')
                    log_trace.append(line)

            return render (request,'iSkyLIMS_wetlab/ConfigurationTest.html', {'runNextSeq_results': runNextSeq_results,
                                                    'log_trace': log_trace, 'basic_checks_ok' : 'OK'})
        else:
            runNextSeq_results['processing_bcl2fastq_ok'] =  'OK'

        # Processed Bcl2fastq
        runNextSeq_results['Processed_Bcl2fastq'] , result_ok = run_test_Processed_Bcl2fastq_to_Completed (experiment_name)
        if result_ok == 'NOK' :
            with open (log_file, 'r') as fh :
                for line in fh :
                    line = line.replace('\n', '')
                    log_trace.append(line)

            return render (request,'iSkyLIMS_wetlab/ConfigurationTest.html', {'runNextSeq_results': runNextSeq_results,
                                                    'log_trace': log_trace, 'basic_checks_ok' : 'OK'})
        else:
            runNextSeq_results['processed_bcl2fast2_ok'] =  'OK'
            runNextSeq_results['completed_ok'] = 'ok'

        return render (request,'iSkyLIMS_wetlab/ConfigurationTest.html', {'runNextSeq_results': runNextSeq_results,
                                                    'log_trace': log_trace, 'basic_checks_ok' : 'OK'})






    elif request.method=='POST' and request.POST['action'] == 'runMiSeq':
        if 'Delete' in request.POST :
            delete_test_run ('MiSeq_Test_0001')
            return render(request,'iSkyLIMS_wetlab/ConfigurationTest.html')

        runMiSeq_results = {}
        log_trace = []
        config_file = os.path.join(settings.BASE_DIR,'iSkyLIMS_wetlab', 'tests', 'logging_test_config.ini' )
        log_file = get_log_file_name(config_file)
        if os.path.isfile (log_file):
            os.remove(log_file)
        logger=open_log(config_file)

        logger.info('###########---Start Testing MiSeq Run  -----############')
        if run_exists_in_db('MiSeq_Test_0001'):
            delete_graphic_folder_if_exists ('MiSeq_Test_0001')
            delete_run_in_db('MiSeq_Test_0001')
            logger.info('Deleting miSEq test run from previous test')

        test_run_remote_folder = 'MiSeq_Test'
        experiment_name = 'MiSeq_Test_0001'
        # Start testing on recorded state
        runMiSeq_results['Recorded'] , result_ok = run_miseq_test_rec_to_sample_sent(test_run_remote_folder, experiment_name)

        if result_ok == 'NOK' :
            with open (log_file, 'r') as fh :
                for line in fh :
                    line = line.replace('\n', '')
                    log_trace.append(line)
            #import pdb; pdb.set_trace()
            return render (request,'iSkyLIMS_wetlab/ConfigurationTest.html', {'runMiSeq_results': runMiSeq_results,
                                                    'log_trace': log_trace, 'basic_checks_ok' : 'OK'})
        else:
            runMiSeq_results['recorded_ok'] =  'OK'

        # Processing Run
        runMiSeq_results['Sample_Sent'] , result_ok = run_miseq_test_sample_sent_to_Processing_Run (experiment_name)
        if result_ok == 'NOK' :
            with open (log_file, 'r') as fh :
                for line in fh :
                    line = line.replace('\n', '')
                    log_trace.append(line)

            return render (request,'iSkyLIMS_wetlab/ConfigurationTest.html', {'runMiSeq_results': runMiSeq_results,
                                                    'log_trace': log_trace, 'basic_checks_ok' : 'OK'})
        else:
            runMiSeq_results['sample_sent_ok'] =  'OK'

        # Processing Run
        runMiSeq_results['Processing_Run'] , result_ok = run_miseq_test_Processing_Run_to_Processed_Run (experiment_name)
        if result_ok == 'NOK' :
            with open (log_file, 'r') as fh :
                for line in fh :
                    line = line.replace('\n', '')
                    log_trace.append(line)

            return render (request,'iSkyLIMS_wetlab/ConfigurationTest.html', {'runMiSeq_results': runMiSeq_results,
                                                    'log_trace': log_trace, 'basic_checks_ok' : 'OK'})
        else:
            runMiSeq_results['processing_run_ok'] =  'OK'

        # Processed Run
        runMiSeq_results['Processed_Run'] , result_ok = run_test_Processed_Run_to_Processing_Bcl2fastq (experiment_name)
        if result_ok == 'NOK' :
            with open (log_file, 'r') as fh :
                for line in fh :
                    line = line.replace('\n', '')
                    log_trace.append(line)

            return render (request,'iSkyLIMS_wetlab/ConfigurationTest.html', {'runMiSeq_results': runMiSeq_results,
                                                    'log_trace': log_trace, 'basic_checks_ok' : 'OK'})
        else:
            runMiSeq_results['processed_run_ok'] =  'OK'

        # Processing Bcl2fastq
        runMiSeq_results['Processing_Bcl2fastq'] , result_ok = run_test_Processing_Bcl2fastq_to_Processed_Bcl2fastq (experiment_name)
        if result_ok == 'NOK' :
            with open (log_file, 'r') as fh :
                for line in fh :
                    line = line.replace('\n', '')
                    log_trace.append(line)

            return render (request,'iSkyLIMS_wetlab/ConfigurationTest.html', {'runMiSeq_results': runMiSeq_results,
                                                    'log_trace': log_trace, 'basic_checks_ok' : 'OK'})
        else:
            runMiSeq_results['processing_bcl2fastq_ok'] =  'OK'

        # Processed Bcl2fastq
        runMiSeq_results['Processed_Bcl2fastq'] , result_ok = run_test_Processed_Bcl2fastq_to_Completed (experiment_name)
        if result_ok == 'NOK' :
            with open (log_file, 'r') as fh :
                for line in fh :
                    line = line.replace('\n', '')
                    log_trace.append(line)

            return render (request,'iSkyLIMS_wetlab/ConfigurationTest.html', {'runMiSeq_results': runMiSeq_results,
                                                    'log_trace': log_trace, 'basic_checks_ok' : 'OK'})
        else:
            runMiSeq_results['processed_bcl2fast2_ok'] =  'OK'
            runMiSeq_results['completed_ok'] = 'ok'

        return render (request,'iSkyLIMS_wetlab/ConfigurationTest.html', {'runMiSeq_results': runMiSeq_results,
                                                    'log_trace': log_trace, 'basic_checks_ok' : 'OK'})


    else:
        return render(request,'iSkyLIMS_wetlab/ConfigurationTest.html')

@login_required
def create_protocol (request):
    ## Check user == WETLAB_MANAGER: if false,  redirect to 'login' page
    if request.user.is_authenticated:
        if not is_wetlab_manager(request):
            return render (
                request,'iSkyLIMS_wetlab/error_page.html',
                {'content':['You do not have enough privileges to see this page ',
                            'Contact with your administrator .']})
    else:
        #redirect to login webpage
        return redirect ('/accounts/login')
    # get the list of defined protocols
    defined_protocols, other_protocol_list = display_available_protocols ()
    defined_protocol_types = display_protocol_types ()


    if request.method == 'POST' and request.POST['action'] == 'addNewProtocol':
        import pdb; pdb.set_trace()
        new_protocol = request.POST['newProtocolName']
        protocol_type = request.POST['protocolType']
        description = request.POST['description']

        if check_if_protocol_exists (new_protocol):
            return render ( request,'iSkyLIMS_wetlab/error_page.html',{'content':['Protocol Name ', new_protocol,
                            'Already exists.']})
        new_protocol_id = create_new_protocol(new_protocol, protocol_type, description)

        return render(request, 'iSkyLIMS_wetlab/createProtocol.html',{'defined_protocols': defined_protocols,
                            'defined_protocol_types':defined_protocol_types, 'new_defined_protocol': new_protocol,
                            'new_protocol_id':new_protocol_id})
    import pdb; pdb.set_trace()
    return render(request, 'iSkyLIMS_wetlab/createProtocol.html',{'defined_protocols': defined_protocols,
                        'defined_protocol_types':defined_protocol_types, 'other_protocol_list' :other_protocol_list})

@login_required
def display_protocol (request, protocol_id):
    if not is_wetlab_manager(request):
        return render (request,'iSkyLIMS_wetlab/error_page.html',
            {'content':['You do not have enough privileges to see this page ',
                        'Contact with your administrator .']})
    #import pdb; pdb.set_trace()
    if not check_if_protocol_exists(protocol_id):
        return render (request,'iSkyLIMS_wetlab/error_page.html',
            {'content':['The protocol that you are trying to get ',
                        'DOES NOT exists .']})
    protocol_data = get_all_protocol_info (protocol_id)
    '''
    na_params = []
    lib_params = []
    protocol_obj = ProtocolInLab.objects.get(pk= protocol_id)
    if ProtocolParameters.objects.filter(protocol_id = protocol_obj).exists():

        nucleic_params = NAProtocolParameters.objects.filter(protocol_id = protocol_obj).order_by('parameterOrder')
        for nucleic_param in nucleic_params:
            na_params.append(nucleic_param.get_na_params().split(';'))
    if LibraryProtocolParameters.objects.filter(protocol_id = protocol_obj).exists():

        library_params = LibraryProtocolParameters.objects.filter(protocol_id = protocol_obj)
        for library_param in library_params:
            lib_params.append(library_param.get_lib_params().split(';'))
    protocol_data['na_params'] = na_params
    protocol_data['lib_params'] = lib_params
    protocol_data['heading'] = ['Parameter Name', 'Order', 'Used', 'Min Value', 'Max Value', 'Description']
    '''
    import pdb; pdb.set_trace()
    return render(request, 'iSkyLIMS_wetlab/displayProtocol.html', {'protocol_data': protocol_data})


@login_required
def define_protocol_parameters (request, protocol_id):

    ## Check user == WETLAB_MANAGER: if false,  redirect to 'login' page
    if request.user.is_authenticated:
        if not is_wetlab_manager(request):
            return render ( request,'iSkyLIMS_wetlab/error_page.html',
                {'content':['You do not have enough privileges to see this page ',
                            'Contact with your administrator .']})
    else:
        #redirect to login webpage
        return redirect ('/accounts/login')

    if request.method == 'POST' and request.POST['action'] == 'define_protocol_parameters':

        recorded_prot_parameters = set_protocol_parameters(request)

        return render(request, 'iSkyLIMS_wetlab/defineProtocolParameters.html', {'recorded_prot_parameters':recorded_prot_parameters})

    else:
        if not check_if_protocol_exists(protocol_id):
            return render ( request,'iSkyLIMS_wetlab/error_page.html',
                        {'content':['The requested Protocol does not exist',
                            'Create the protocol name before assigning custom protocol parameters.']})


        prot_parameters = define_table_for_prot_parameters(protocol_id)
        return render(request, 'iSkyLIMS_wetlab/defineProtocolParameters.html', {'prot_parameters':prot_parameters})

@login_required
def add_commercial_kit (request):

    return render(request, 'iSkyLIMS_wetlab/AddCommercialKit.html')

@login_required
def pending_to_update(request):
    pending = {}
    # get the samples in defined state
    pending['defined'] = get_samples_in_defined_state()
    pending['extract_molecule'] = get_samples_in_extracted_molecule_state()
    pending['add_library_preparation'] = get_samples_in_add_library_preparation_state()
    pending['add_lib_prep_parameters'] = get_samples_add_lib_prep_parameters()
    # get the molecules  in  defined state
    #pending['molecules'] = get_molecules_in_state('Defined')
    # get the library preparation in defined state

    #import pdb; pdb.set_trace()
    return render(request, 'iSkyLIMS_wetlab/pendingToUpdate.html', {'pending':pending})


@login_required
def record_samples(request):
    if request.method == 'POST' and request.POST['action'] == 'recordsample':
        sample_recorded = analyze_input_samples (request)
        # if no samples are in any of the options, displays the inital page
        if (not 'valid_samples' in sample_recorded and not 'invalid_samples' in sample_recorded) :
            sample_information = prepare_sample_input_table()
            return render(request, 'iSkyLIMS_wetlab/recordSample.html',{'sample_information':sample_information})
        else :
            return render(request, 'iSkyLIMS_wetlab/recordSample.html',{'sample_recorded':sample_recorded})
    elif request.method == 'POST' and request.POST['action'] == 'reprocessSamples':
        import pdb; pdb.set_trace()
    else:
        sample_information = prepare_sample_input_table()
        return render(request, 'iSkyLIMS_wetlab/recordSample.html',{'sample_information':sample_information})

@login_required
def display_libSample (request, sample_id):
    sample_information = get_all_sample_information(sample_id)
    if 'Error' in sample_information:
        return render (request,'iSkyLIMS_wetlab/error_page.html', {'content':['No Sample was found']})
    sample_information.update(get_all_library_information(sample_id))
    import pdb; pdb.set_trace()
    return render(request, 'iSkyLIMS_wetlab/displayLibSample.html',{'sample_information':sample_information})


@login_required
def search_lib_samples (request):
    if  request.method == 'POST' and request.POST['action'] == 'searchsample':
        sample_name=request.POST['samplename']
        start_date=request.POST['startdate']
        end_date=request.POST['enddate']
        user_name = request.POST['username']
        sample_state =request.POST['sampleState']

        # check that some values are in the request if not return the form
        if user_name == '' and start_date == '' and end_date == '' and sample_name =='' and sample_state == '':
            search_data = {}
            search_data['s_state'] = get_sample_states()
            return render(request, 'iSkyLIMS_wetlab/searchLibSample.html',{'search_data':search_data})

        if user_name !=''  and len(user_name) <5 :
            return render (request,'iSkyLIMS_wetlab/error_page.html', {'content':['The user name must contains at least 5 caracters ',
                    'ADVICE:', 'write the full user name to get a better match']})
        ### check the right format of start and end date
        if start_date != '' and not check_valid_date_format(start_date):
            return render (request,'iSkyLIMS_wetlab/error_page.html', {'content':['The format for the "Start Date Search" Field is incorrect ',
                    'ADVICE:', 'Use the format  (DD-MM-YYYY)']})
        if end_date != '' and not check_valid_date_format(end_date):
            return render (request,'iSkyLIMS_wetlab/error_page.html', {'content':['The format for the "End Date Search" Field is incorrect ',
                     'ADVICE:', 'Use the format  (DD-MM-YYYY)']})
        ### Get projects when sample name is not empty

        sample_list = search_samples(sample_name, user_name, sample_state, start_date, end_date )
        import pdb; pdb.set_trace()
        if len(sample_list) == 0:
            return render (request,'iSkyLIMS_wetlab/error_page.html', {'content':['No sample found with your match conditions ']})
        elif len(sample_list) == 1:
            import pdb; pdb.set_trace()
            return redirect ('display_libSample' , sample_id = sample_list[0])
        else:
            return render(request, 'iSkyLIMS_wetlab/searchLibSample.html',{'sample_list':sample_list})

    else:
        search_data = {}
        search_data['s_state'] = get_sample_states()
        return render(request, 'iSkyLIMS_wetlab/searchLibSample.html',{'search_data':search_data})

@login_required
def set_Molecule_values(request):
    if request.method == 'POST' and request.POST['action'] == 'continueWithMolecule':
        if request.POST['samples'] == '':
            return render (request,'iSkyLIMS_wetlab/error_page.html',
                {'content':['There was no sample selected ']})
        if  'samples_in_list' in request.POST:
            samples = request.POST.getlist('samples')
        else:
            samples = request.POST['samples'].split(',')

        molecule_protocol = get_table_record_molecule (samples)
        if 'ERROR' in molecule_protocol :
            return render (request, 'iSkyLIMS_wetlab/error_page.html',
                {'content':['There was no valid sample selected ']})
        molecule_protocol['protocol_type'] = list(molecule_protocol['protocols_dict'].keys())
        molecule_protocol['protocol_filter_selection'] = []
        for key, value in molecule_protocol['protocols_dict'].items():
            molecule_protocol['protocol_filter_selection'].append([key, value])
        molecule_protocol['samples'] = ','.join(samples)

        return render(request, 'iSkyLIMS_wetlab/setMoleculeValues.html',{'molecule_protocol':molecule_protocol})

    elif request.method == 'POST' and request.POST['action'] == 'updateMoleculeProtocol':

        molecule_recorded = record_molecules (request)

        return render(request, 'iSkyLIMS_wetlab/setMoleculeValues.html',{'molecule_recorded':molecule_recorded})

    elif request.method == 'POST' and request.POST['action'] == 'displayMoleculeParameters':
        if  'samples_in_list' in request.POST:
            molecules = request.POST.getlist('molecules')
        else:
            molecules = request.POST['molecules'].split(',')
        show_molecule_parameters = display_molecule_protocol_parameters(molecules)
        return render(request, 'iSkyLIMS_wetlab/setMoleculeValues.html',{'show_molecule_parameters':show_molecule_parameters})

    elif request.method == 'POST' and request.POST['action'] == 'addMoleculeParameters':
        added_molecule_protocol_parameters = add_molecule_protocol_parameters(request)
        return render(request, 'iSkyLIMS_wetlab/setMoleculeValues.html',{'added_molecule_protocol_parameters':added_molecule_protocol_parameters})
    else:
        register_user = request.user.username
        display_list = get_defined_samples (register_user)
        '''
        s_list = []
        all_sample_list = []
        display_list = {}

        for key in grouped_samples_obj.keys():
            s_list = []
            for sample in grouped_samples_obj[key]:
                s_info = sample.get_sample_definition_information().split(';')
                s_info.append(str(sample.pk))
                s_list.append(s_info)
            all_sample_list.append(s_list)

        '''
        #display_list['list_of_samples'] = all_sample_list
        #display_list['heading'] = ['Registered date ','Sample Code ID', 'Type', 'DNA/RNA', 'Protocol', 'To be included']
        #import pdb; pdb.set_trace()
        return render(request, 'iSkyLIMS_wetlab/setMoleculeValues.html',{'display_list': display_list})
    return render(request, 'iSkyLIMS_wetlab/setMoleculeValues.html',{})

@login_required
def set_library_preparation(request):
    if request.method == 'POST' and request.POST['action'] == 'displayLibraryPreparation':
        if not 'molecules' in request.POST :
            return render (request,'iSkyLIMS_wetlab/error_page.html',
                {'content':['There was no molecule selected ']})
        if  'molecules_in_list' in request.POST:
            molecules = request.POST.getlist('molecules')
        else:
            molecules = request.POST['molecules'].split(',')
        display_lib_prep = {}
        display_lib_prep['data'] = []
        defined_protocols_lib = get_protocol_lib()

        if len(defined_protocols_lib) == 0 :
            return render ( request,'iSkyLIMS_wetlab/error_page.html',
                        {'content':['Protocols for library preparation is a pre-requisite to defined the settings for library preparations',
                            'Define them and then return to continue with this step.']})
        display_lib_prep ['protocol_lib'] = defined_protocols_lib
        display_lib_prep ['heading'] = HEADING_FOR_CREATION_LIBRARY_PREPARATION
        display_lib_prep ['heading_in_excel'] = ','.join(HEADING_FOR_CREATION_LIBRARY_PREPARATION)
        length_heading = len(HEADING_FOR_CREATION_LIBRARY_PREPARATION)

        for molecule in molecules :
            data = ['']*length_heading
            molecule_obj = MoleculePreparation.objects.get(pk = int(molecule))
            data[0] = molecule_obj.get_molecule_code_id()
            display_lib_prep['data'].append(data)
        display_lib_prep['molecules'] = molecules
        return render (request, 'iSkyLIMS_wetlab/setLibraryPreparation.html', {'display_lib_prep':display_lib_prep})

    elif request.method == 'POST' and request.POST['action'] == 'importsamplesheet':
        protocol = request.POST['lib_protocols']
        single_paired = request.POST['singlePairedEnd']
        read_length = request.POST['readlength']
        extension_file = '.csv'
        stored_file , file_name = store_user_input_file(request.FILES['importsamplesheet'], extension_file)

        library_prep_workflow = get_library_name(stored_file)
        index_adapters = get_indexes_adapters (stored_file)
        samples_dict = get_samples_in_sample_sheet(stored_file)
        # store user sample sheet in database
        user_sample_sheet_data = {}
        stored_lib_prep = {}
        stored_lib_prep['data'] = []
        if IndexLibraryKit.objects.filter(indexLibraryName__exact = index_adapters).exists():
            indexLibraryKit_id = IndexLibraryKit.objects.get(indexLibraryName__exact = index_adapters)
        else:
            indexLibraryKit_id = None
        register_user_obj = User.objects.get(username__exact = request.user.username)
        user_sample_sheet_data['registerUser'] = register_user_obj
        protocol_obj = Protocols.objects.get(name__exact = protocol)
        user_sample_sheet_data['indexLibraryKit_id'] = indexLibraryKit_id

        user_sample_sheet_data['sampleSheet'] = file_name
        new_user_s_sheet_obj = libPreparationUserSampleSheet.objects.create_lib_prep_user_sample_sheet(user_sample_sheet_data)

        extracted_data_list = extract_sample_data (samples_dict)
        parameter_heading = get_protocol_parameters(protocol_obj)
        length_heading = len(HEADING_FIX_FOR_ADDING_LIB_PARAMETERS) + len (parameter_heading)
        stored_lib_prep['heading'] = HEADING_FIX_FOR_ADDING_LIB_PARAMETERS
        stored_lib_prep['par_heading'] = parameter_heading
        stored_lib_prep['heading_in_excel'] = ','.join(HEADING_FIX_FOR_ADDING_LIB_PARAMETERS + parameter_heading)
        lib_prep_id = []
        samples_not_available = []
        stored_lib_prep['reagents_kits'] = get_user_comercial_kits(register_user_obj, protocol_obj)
        for extracted_data in extracted_data_list :
            import pdb; pdb.set_trace()
            if Samples.objects.filter(sampleName__exact = extracted_data['sample_id'], sampleUser = register_user_obj,
                            sampleState__sampleStateName = 'Add Library preparation').exists():

                sample_obj = Samples.objects.get(sampleName__exact = extracted_data['sample_id'])
                extracted_data['sample_id'] = sample_obj
                #samples_id.append(sample_obj.get_sample_id())

                extracted_data['protocol_obj'] = protocol_obj
                molecule_obj = MoleculePreparation.objects.filter(sample = sample_obj).last()
                if libraryPreparation.objects.filter(sample_id = sample_obj).exists():
                    last_lib_prep_code_id = libraryPreparation.objects.filter(sample_id = sample_obj).last().get_lib_prep_code()
                    split_code = re.search('(.*_)(\d+)$',last_lib_prep_code_id)
                    index_val = int(split_code.group(2))
                    new_index = str(index_val +1).zfill(2)
                    lib_prep_code_id = split_code.group(1) + new_index
                else:
                    lib_prep_code_id = molecule_obj.get_molecule_code_id() + '_LIB_01'
                extracted_data['lib_code_id'] = lib_prep_code_id
                # Create the new library preparation object
                new_library_preparation = libraryPreparation.objects.create_lib_preparation(extracted_data, new_user_s_sheet_obj, register_user_obj,
                                        molecule_obj,  single_paired , read_length)
                lib_prep_id.append(new_library_preparation.get_id())
                data = ['']*length_heading
                data[0] = extracted_data['sample_id']
                data[1] = lib_prep_code_id
                stored_lib_prep['data'].append(data)

            else:
                samples_not_available.append(extracted_data['sample_id'])

        stored_lib_prep['lib_prep_id'] = ','.join(lib_prep_id)
        import pdb; pdb.set_trace()
        return render (request, 'iSkyLIMS_wetlab/setLibraryPreparation.html', {'stored_lib_prep':stored_lib_prep})

    elif request.method == 'POST' and request.POST['action'] == 'addProtocolParamters':


        stored_params = analyze_input_param_values (request)
        '''
        if  'samples_in_list' in request.POST:
            samples = request.POST.getlist('samples')
            if len(samples) == 0:
                samples = list(request.POST['samples'])
        else:
            samples = request.POST['samples'].split(',')
        stored_lib_prep = {}
        stored_lib_prep['data'] = []
        length_heading = len(HEADING_FIX_FOR_ADDING_LIB_PARAMETERS)
        stored_lib_prep['heading'] = HEADING_FIX_FOR_ADDING_LIB_PARAMETERS
        stored_lib_prep['heading_in_excel'] = ','.join(HEADING_FIX_FOR_ADDING_LIB_PARAMETERS)

        for sample in samples:
            if not libraryPreparation.objects.filter(pk__exact = int(sample)).exists():
                continue
            lib_prep_obj = libraryPreparation.objects.get(pk__exact = int(sample))
            data = ['']*length_heading
            data[0] = lib_prep_obj.get_lib_prep_code()
            stored_lib_prep['data'].append(data)
        '''
        return render (request, 'iSkyLIMS_wetlab/setLibraryPreparation.html', {'stored_params':stored_params})

    elif request.method == 'POST' and request.POST['action'] == 'addLibraryProtocol':
        if  'molecules_in_list' in request.POST:
            molecules = request.POST.getlist('molecules')
        else:
            molecules = request.POST['molecules'].split(',')
        prot_lib_json_data = json.loads(request.POST['protocol_data'])
        heading_in_excel = request.POST['heading_in_excel'].split(',')


        for i in range(len(molecules)) :
            valid_molecules = []
            protocol_name = prot_lib_json_data[i][heading_in_excel.index('Protocol used')]
            if protocol_name == '':
                continue
            if not Protocols.objects.filter(name__exact = protocol_name).exists():
                continue
            protocol_obj = Protocols.objects.get(name__exact = protocol_name)
            if not ProtocolLibraryParameters.objects.filter(protocol_id = protocol_obj).exists():
                continue
            valid_molecules.append(molecules[i])
            prot_lib_parameters = ProtocolLibraryParameters.objects.filter(protocol_id = protocol_obj)


@login_required
def set_library_values (request):
    fix_headings = ['DNA Code ID', 'Protocol', 'Extraction Kit']
    import pdb; pdb.set_trace()
    if request.method == 'POST' and request.POST['action'] == 'continueWithDNA':
        lib_preparation_data = {}
    else:
        register_user = request.user.username
        grouped_samples_obj = get_samples_for_library_definition (register_user)
        s_list = []
        all_sample_list = []
        display_list = {}

        for key in grouped_samples_obj.keys():
            s_list = []
            for sample in grouped_samples_obj[key]:
                s_info = sample.get_sample_definition_information().split(';')
                s_info.append(str(sample.pk))
                s_list.append(s_info)
            all_sample_list.append(s_list)

        display_list['lib_kits'] = get_available_lib_kit(register_user)

        display_list['list_of_samples'] = all_sample_list
        display_list['heading'] = ['Registered date ','Sample Code ID', 'Type', 'DNA/RNA', 'Protocol', 'Library Kit']
        #import pdb; pdb.set_trace()
        return render(request, 'iSkyLIMS_wetlab/setLibraryValues.html',{'display_list': display_list})
    #import pdb; pdb.set_trace()



@login_required
def select_samples_for_run (request):
    ## Check user == WETLAB_MANAGER: if false,  redirect to 'login' page
    if request.user.is_authenticated:
        if not is_wetlab_manager(request):
            return render ( request,'iSkyLIMS_wetlab/error_page.html',
                {'content':['You do not have enough privileges to see this page ',
                            'Contact with your administrator .']})
    else:
        #redirect to login webpage
        return redirect ('/accounts/login')
    display_list = {}
    s_list = []
    all_sample_list = []


    if SamplesInProject.objects.filter(sampleState__sampleStateName = 'Added Library Info').exists():
        samples_obj = SamplesInProject.objects.filter(sampleState__sampleStateName = 'Added Library Info').order_by('sampleExtractionDate')
        for sample_obj in samples_obj :
            s_info = sample.get_sample_definition_information().split(';')
            s_info.append(str(sample.pk))
            s_list.append(s_info)
            all_sample_list.append(s_list)
    display_list['heading'] = ['Register Date', 'Sample Code ID', 'Sample Type', 'Index I7', 'Index I5']

    return  render(request, 'iSkyLIMS_wetlab/selectSamplesForRun.html',{'display_list': display_list})
